<!DOCTYPE HTML>
<html lang="zh_CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="零基础入门深度学习-循环神经网络, Matter">
    <meta name="description" content="参考资料：https://www.zybuluo.com/hanbingtao/note/541458

%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/22566">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>零基础入门深度学习-循环神经网络 | Matter</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="../index.html" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Matter</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>文章分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Matter</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			文章分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">零基础入门深度学习-循环神经网络</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="../categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                深度学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2019-12-20
                </div>
                

                

                

                

                
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>参考资料：<a href="https://www.zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">https://www.zybuluo.com/hanbingtao/note/541458</a></p>
<hr>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-06627c71f0d8c0dc.jpg)</p>
<blockquote>
<p>无论即将到来的是大数据时代还是人工智能时代，亦或是传统行业使用人工智能在云上处理大数据的时代，作为一个有理想有追求的程序员，不懂深度学习（Deep Learning）这个超热的技术，会不会感觉马上就out了？现在救命稻草来了，《零基础入门深度学习》系列文章旨在讲帮助爱编程的你从零基础达到入门级水平。零基础意味着你不需要太多的数学知识，只要会写程序就行了，没错，这是专门为程序员写的文章。虽然文中会有很多公式你也许看不懂，但同时也会有更多的代码，程序员的你一定能看懂的（我周围是一群狂热的Clean Code程序员，所以我写的代码也不会很差）。</p>
</blockquote>
<h2 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h2><p>在前面的文章系列文章中，我们介绍了全连接神经网络和卷积神经网络，以及它们的训练和使用。他们都只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理<strong>序列</strong>的信息，即前面的输入和后面的输入是有关系的。比如，当我们在理解一句话意思时，孤立的理解这句话的每个词是不够的，我们需要处理这些词连接起来的整个<strong>序列</strong>；当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个<strong>序列</strong>。这时，就需要用到深度学习领域中另一类非常重要神经网络：<strong>循环神经网络(Recurrent Neural Network)</strong>。RNN种类很多，也比较绕脑子。不过读者不用担心，本文将一如既往的对复杂的东西剥茧抽丝，帮助您理解RNNs以及它的训练算法，并动手实现一个<strong>循环神经网络</strong>。</p>
<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>RNN是在<strong>自然语言处理</strong>领域中最先被用起来的，比如，RNN可以为<strong>语言模型</strong>来建模。那么，什么是语言模型呢？</p>
<p>我们可以和电脑玩一个游戏，我们写出一个句子前面的一些词，然后，让电脑帮我们写下接下来的一个词。比如下面这句：</p>
<blockquote>
<p>我昨天上学迟到了，老师批评了____。</p>
</blockquote>
<p>我们给电脑展示了这句话前面这些词，然后，让电脑写下接下来的一个词。在这个例子中，接下来的这个词最有可能是『我』，而不太可能是『小明』，甚至是『吃饭』。</p>
<p><strong>语言模型</strong>就是这样的东西：给定一个一句话前面的部分，预测接下来最有可能的一个词是什么。</p>
<p><strong>语言模型</strong>是对一种语言的特征进行建模，它有很多很多用处。比如在语音转文本(STT)的应用中，声学模型输出的结果，往往是若干个可能的候选词，这时候就需要<strong>语言模型</strong>来从这些候选词中选择一个最可能的。当然，它同样也可以用在图像到文本的识别中(OCR)。</p>
<p>使用RNN之前，语言模型主要是采用N-Gram。N可以是一个自然数，比如2或者3。它的含义是，假设一个词出现的概率只与前面N个词相关。我们以2-Gram为例。首先，对前面的一句话进行切词：</p>
<blockquote>
<p>我 昨天 上学 迟到 了 ，老师 批评 了 ____。</p>
</blockquote>
<p>如果用2-Gram进行建模，那么电脑在预测的时候，只会看到前面的『了』，然后，电脑会在语料库中，搜索『了』后面最可能的一个词。不管最后电脑选的是不是『我』，我们都知道这个模型是不靠谱的，因为『了』前面说了那么一大堆实际上是没有用到的。如果是3-Gram模型呢，会搜索『批评了』后面最可能的词，感觉上比2-Gram靠谱了不少，但还是远远不够的。因为这句话最关键的信息『我』，远在9个词之前！</p>
<p>现在读者可能会想，可以提升继续提升N的值呀，比如4-Gram、5-Gram…….。实际上，这个想法是没有实用性的。因为我们想处理任意长度的句子，N设为多少都不合适；另外，模型的大小和N的关系是指数级的，4-Gram模型就会占用海量的存储空间。</p>
<p>所以，该轮到RNN出场了，RNN理论上可以往前看(往后看)任意多个词。</p>
<h2 id="循环神经网络是啥"><a href="#循环神经网络是啥" class="headerlink" title="循环神经网络是啥"></a>循环神经网络是啥</h2><p>循环神经网络种类繁多，我们先从最简单的基本循环神经网络开始吧。</p>
<h3 id="基本循环神经网络"><a href="#基本循环神经网络" class="headerlink" title="基本循环神经网络"></a>基本循环神经网络</h3><p>下图是一个简单的循环神经网络如，它由输入层、一个隐藏层和一个输出层组成：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-479f2a7488b91671.jpg)</p>
<p>纳尼？！相信第一次看到这个玩意的读者内心和我一样是崩溃的。因为<strong>循环神经网络</strong>实在是太难画出来了，网上所有大神们都不得不用了这种抽象艺术手法。不过，静下心来仔细看看的话，其实也是很好理解的。如果把上面有W的那个带箭头的圈去掉，它就变成了最普通的<strong>全连接神经网络</strong>。x是一个向量，它表示<strong>输入层</strong>的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示<strong>隐藏层</strong>的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；U是输入层到隐藏层的<strong>权重矩阵</strong>（读者可以回到第三篇文章<a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">零基础入门深度学习(3) - 神经网络和反向传播算法</a>，看看我们是怎样用矩阵来表示<strong>全连接神经网络</strong>的计算的）；o也是一个向量，它表示<strong>输出层</strong>的值；V是隐藏层到输出层的<strong>权重矩阵</strong>。那么，现在我们来看看W是什么。<strong>循环神经网络</strong>的<strong>隐藏层</strong>的值s不仅仅取决于当前这次的输入x，还取决于上一次<strong>隐藏层</strong>的值s。<strong>权重矩阵</strong> W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重。</p>
<p>如果我们把上面的图展开，<strong>循环神经网络</strong>也可以画成下面这个样子：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-cf18bb1f06e750a4.jpg)</p>
<p>现在看上去就比较清楚了，这个网络在t时刻接收到输入之后，隐藏层的值是，输出值是。关键一点是，的值不仅仅取决于，还取决于。我们可以用下面的公式来表示<strong>循环神经网络</strong>的计算方法：</p>
<p>$\begin{align} \mathrm{o}_t&amp;=g(V\mathrm{s}_t)\qquad\qquad\quad(式1)\\ \mathrm{s}_t&amp;=f(U\mathrm{x}_t+W\mathrm{s}_{t-1})\qquad(式2)\\ \end{align} $</p>
<p><strong>式1</strong>是<strong>输出层</strong>的计算公式，输出层是一个<strong>全连接层</strong>，也就是它的每个节点都和隐藏层的每个节点相连。V是输出层的<strong>权重矩阵</strong>，g是<strong>激活函数</strong>。式2是隐藏层的计算公式，它是<strong>循环层</strong>。U是输入x的权重矩阵，W是上一次的值$\mathrm{s}_{t-1}$作为这一次的输入的<strong>权重矩阵</strong>，f是<strong>激活函数</strong>。</p>
<p>从上面的公式我们可以看出，<strong>循环层</strong>和<strong>全连接层</strong>的区别就是<strong>循环层</strong>多了一个<strong>权重矩阵</strong> W。</p>
<p>如果反复把<strong>式2</strong>带入到<strong>式1</strong>，我们将得到：</p>
<p>$\begin {align}\mathrm{o}_t&amp;=g(V\mathrm{s}_t)\\ &amp;=Vf(U\mathrm{x}_t+W\mathrm{s}_{t-1})\\ &amp;=Vf(U\mathrm{x}_t+Wf(U\mathrm{x}_{t-1}+W\mathrm{s}_{t-2}))\\ &amp;=Vf(U\mathrm{x}_t+Wf(U\mathrm{x}_{t-1}+Wf(U\mathrm{x}_{t-2}+W\mathrm{s}_{t-3})))\\ &amp;=Vf(U\mathrm{x}_t+Wf(U\mathrm{x}_{t-1}+Wf(U\mathrm{x}_{t-2}+Wf(U\mathrm{x}_{t-3}+…)))) \end{align}$</p>
<p>从上面可以看出，<strong>循环神经网络</strong>的输出值，是受前面历次输入值$\mathrm{x}_{t}$, $\mathrm{x}_{t-1}$…影响的，这就是为什么<strong>循环神经网络</strong>可以往前看任意多个<strong>输入值</strong>的原因。</p>
<h3 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h3><p>对于<strong>语言模型</strong>来说，很多时候光看前面的词是不够的，比如下面这句话：</p>
<blockquote>
<p>我的手机坏了，我打算____一部新手机。</p>
</blockquote>
<p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的。但如果我们也看到了横线后面的词是『一部新手机』，那么，横线上的词填『买』的概率就大得多了。</p>
<p>在上一小节中的<strong>基本循环神经网络</strong>是无法对此进行建模的，因此，我们需要<strong>双向循环神经网络</strong>，如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-039a45251aa5d220.png)</p>
<p>当遇到这种从未来穿越回来的场景时，难免处于懵逼的状态。不过我们还是可以用屡试不爽的老办法：先分析一个特殊场景，然后再总结一般规律。我们先考虑上图中$\mathrm{y}_2$的计算。</p>
<p>从上图可以看出，<strong>双向卷积神经网络</strong>的隐藏层要保存两个值，一个A参与正向计算，另一个值A’参与反向计算。最终的输出值$\mathrm{y}_2$取决于$A_2$和$A_2’$。其计算方法为：</p>
<p>$\mathrm{y}_2=g(VA_2+V’A_2’)$</p>
<p>$A_2$和$A_2’$则分别计算：</p>
<p>$\begin{align} A_2&amp;=f(WA_1+U\mathrm{x}_2)\\ A_2’&amp;=f(W’A_3’+U’\mathrm{x}_2)\\ \end {align}$</p>
<p>现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$s_t$与$s_{t-1}$有关；反向计算时，隐藏层的值$s_t’$与$s_{t+1}’$有关；最终的输出取决于正向和反向计算的<strong>加和</strong>。现在，我们仿照<strong>式1</strong>和<strong>式2</strong>，写出双向循环神经网络的计算方法：</p>
<p>$\begin{align} \mathrm{o}_t&amp;=g(V\mathrm{s}_t+V’\mathrm{s}_t’)\\ \mathrm{s}_t&amp;=f(U\mathrm{x}_t+W\mathrm{s}_{t-1})\\ \mathrm{s}_t’&amp;=f(U’\mathrm{x}_t+W’\mathrm{s}_{t+1}’)\\ \end {align}$</p>
<p>从上面三个公式我们可以看到，正向计算和反向计算<strong>不共享权重</strong>，也就是说U和U’、W和W’、V和V’都是不同的<strong>权重矩阵</strong>。</p>
<h3 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h3><p>前面我们介绍的<strong>循环神经网络</strong>只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了<strong>深度循环神经网络</strong>。如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-df137de8007c3d26.png)</p>
<p>我们把第i个隐藏层的值表示为$\mathrm{s}_t^{(i)}$、$\mathrm{s}_t’^{(i)}$，则<strong>深度循环神经网络</strong>的计算方式可以表示为：</p>
<p>$\begin{align} \mathrm{o}_t&amp;=g(V^{(i)}\mathrm{s}_t^{(i)}+V’^{(i)}\mathrm{s}_t’^{(i)})\\ \mathrm{s}_t^{(i)}&amp;=f(U^{(i)}\mathrm{s}_t^{(i-1)}+W^{(i)}\mathrm{s}_{t-1})\\ \mathrm{s}_t’^{(i)}&amp;=f(U’^{(i)}\mathrm{s}_t’^{(i-1)}+W’^{(i)}\mathrm{s}_{t+1}’)\\ …\\ \mathrm{s}_t^{(1)}&amp;=f(U^{(1)}\mathrm{x}_t+W^{(1)}\mathrm{s}_{t-1})\\ \mathrm{s}_t’^{(1)}&amp;=f(U’^{(1)}\mathrm{x}_t+W’^{(1)}\mathrm{s}_{t+1}’)\\ \end {align}$</p>
<h2 id="循环神经网络的训练"><a href="#循环神经网络的训练" class="headerlink" title="循环神经网络的训练"></a>循环神经网络的训练</h2><h3 id="循环神经网络的训练算法：BPTT"><a href="#循环神经网络的训练算法：BPTT" class="headerlink" title="循环神经网络的训练算法：BPTT"></a>循环神经网络的训练算法：BPTT</h3><p>BPTT算法是针对<strong>循环层</strong>的训练算法，它的基本原理和BP算法是一样的，也包含同样的三个步骤：</p>
<ol>
<li>前向计算每个神经元的输出值；</li>
<li>反向计算每个神经元的<strong>误差项</strong>$\delta_j$值，它是误差函数E对神经元j的<strong>加权输入</strong>$net_j$的偏导数；</li>
<li>计算每个权重的梯度。</li>
</ol>
<p>最后再用<strong>随机梯度下降</strong>算法更新权重。</p>
<p>循环层如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-3b20294694c3904b.png)</p>
<h4 id="前向计算"><a href="#前向计算" class="headerlink" title="前向计算"></a>前向计算</h4><p>使用前面的<strong>式2</strong>对循环层进行前向计算：</p>
<p>$ \mathrm{s}_t=f(U\mathrm{x}_t+W\mathrm{s}_{t-1}) $</p>
<p>注意，上面的$\mathrm{s}_t$、$\mathrm{x}_t$、$\mathrm{s}_{t-1}$都是向量，用<strong>黑体字母</strong>表示；而U、V是<strong>矩阵</strong>，用大写字母表示。<strong>向量的下标</strong>表示<strong>时刻</strong>，例如，${s}_t$表示在t时刻向量s的值。</p>
<p>我们假设输入向量x的维度是m，输出向量s的维度是n，则矩阵U的维度是$n\times m$，矩阵W的维度是$n\times n$。下面是上式展开成矩阵的样子，看起来更直观一些：</p>
<p>$\begin{align} \begin{bmatrix} s_1^t\\ s_2^t\\ .\.\\ s_n^t\\ \end{bmatrix}=f( \begin{bmatrix} u_{11} u_{12} … u_{1m}\\ u_{21} u_{22} … u_{2m}\\ .\.\\ u_{n1} u_{n2} … u_{nm}\\ \end{bmatrix} \begin{bmatrix} x_1\\ x_2\\ .\.\\ x_m\\ \end{bmatrix}+ \begin{bmatrix} w_{11} w_{12} … w_{1n}\\ w_{21} w_{22} … w_{2n}\\ .\.\\ w_{n1} w_{n2} … w_{nn}\\ \end{bmatrix} \begin{bmatrix} s_1^{t-1}\\ s_2^{t-1}\\ .\.\\ s_n^{t-1}\\ \end{bmatrix}) \end {align}$</p>
<p>在这里我们用<strong>手写体字母</strong>表示向量的一个<strong>元素</strong>，它的下标表示它是这个向量的第几个元素，它的上标表示第几个<strong>时刻</strong>。例如，$s_j^t$表示向量s的第j个元素在t时刻的值。$u_{ji}$表示<strong>输入层</strong>第i个神经元到<strong>循环层</strong>第j个神经元的权重。$w_{ji}$表示<strong>循环层</strong>第t-1时刻的第i个神经元到<strong>循环层</strong>第t个时刻的第j个神经元的权重。</p>
<h4 id="误差项的计算"><a href="#误差项的计算" class="headerlink" title="误差项的计算"></a>误差项的计算</h4><p>BTPP算法将第l层t时刻的<strong>误差项</strong>$\delta_t^l$值沿两个方向传播，一个方向是其传递到上一层网络，得到$\delta_t^{l-1}$，这部分只和权重矩阵U有关；另一个是方向是将其沿时间线传递到初始$t_1$时刻，得到$\delta_1^l$，这部分只和权重矩阵W有关。</p>
<p>我们用向量$\mathrm{net}_t$表示神经元在t时刻的<strong>加权输入</strong>，因为：</p>
<p>$\begin{align} \mathrm{net}_t&amp;=U\mathrm{x}_t+W\mathrm{s}_{t-1}\\ \mathrm{s}_{t-1}&amp;=f(\mathrm{net}_{t-1})\\ \end {align} $</p>
<p>因此：</p>
<script type="math/tex; mode=display">\begin{align} \frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_{t-1}}}&=\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{s}_{t-1}}}\frac{\partial{\mathrm{s}_{t-1}}}{\partial{\mathrm{net}_{t-1}}}\\ \end {align}</script><p>我们用a表示列向量，用表示$\mathrm{a}^T$行向量。上式的第一项是向量函数对向量求导，其结果为Jacobian矩阵：</p>
<p>$\begin{align} \frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{s}_{t-1}}}&amp;= \begin{bmatrix} \frac{\partial{net_1^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_1^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_1^t}}{\partial{s_n^{t-1}}}\\ \frac{\partial{net_2^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_2^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_2^t}}{\partial{s_n^{t-1}}}\\ &amp;.\\&amp;.\\ \frac{\partial{net_n^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_n^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_n^t}}{\partial{s_n^{t-1}}}\\ \end{bmatrix}\\ &amp;=\begin{bmatrix} w_{11} &amp; w_{12} &amp; … &amp; w_{1n}\\ w_{21} &amp; w_{22} &amp; … &amp; w_{2n}\\ &amp;.\\&amp;.\\ w_{n1} &amp; w_{n2} &amp; … &amp; w_{nn}\\ \end{bmatrix}\\ &amp;=W \end {align}$</p>
<p>同理，上式第二项也是一个Jacobian矩阵：</p>
<p>$\begin{align} \frac{\partial{\mathrm{s}_{t-1}}}{\partial{\mathrm{net}_{t-1}}}&amp;= \begin{bmatrix} \frac{\partial{s_1^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_1^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_1^{t-1}}}{\partial{net_n^{t-1}}}\\ \frac{\partial{s_2^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_2^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_2^{t-1}}}{\partial{net_n^{t-1}}}\\ &amp;.\\&amp;.\\ \frac{\partial{s_n^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_n^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_n^{t-1}}}{\partial{net_n^{t-1}}}\\ \end{bmatrix}\\ &amp;=\begin{bmatrix} f’(net_1^{t-1}) &amp; 0 &amp; … &amp; 0\\ 0 &amp; f’(net_2^{t-1}) &amp; … &amp; 0\\ &amp;.\\&amp;.\\ 0 &amp; 0 &amp; … &amp; f’(net_n^{t-1})\\ \end{bmatrix}\\ &amp;=diag[f’(\mathrm{net}_{t-1})] \end {align}$</p>
<p>其中，diag[a]表示根据向量a创建一个对角矩阵，即</p>
<p>$diag(\mathrm{a})=\begin{bmatrix} a_1 &amp; 0 &amp; … &amp; 0\\ 0 &amp; a_2 &amp; … &amp; 0\\ &amp;.\\&amp;.\\ 0 &amp; 0 &amp; … &amp; a_n\\ \end{bmatrix}\\ $ </p>
<p>最后，将两项合在一起，可得：</p>
<p>$\begin{align} \frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_{t-1}}}&amp;=\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{s}_{t-1}}}\frac{\partial{\mathrm{s}_{t-1}}}{\partial{\mathrm{net}_{t-1}}}\\ &amp;=Wdiag[f’(\mathrm{net}_{t-1})]\\ &amp;=\begin{bmatrix} w_{11}f’(net_1^{t-1}) &amp; w_{12}f’(net_2^{t-1}) &amp; … &amp; w_{1n}f(net_n^{t-1})\\ w_{21}f’(net_1^{t-1}) &amp; w_{22} f’(net_2^{t-1}) &amp; … &amp; w_{2n}f(net_n^{t-1})\\ &amp;.\\&amp;.\\ w_{n1}f’(net_1^{t-1}) &amp; w_{n2} f’(net_2^{t-1}) &amp; … &amp; w_{nn} f’(net_n^{t-1})\\ \end{bmatrix}\\ \end {align}$</p>
<p>上式描述了将沿时间往前传递一个时刻的规律，有了这个规律，我们就可以求得任意时刻k的<strong>误差项</strong>$\delta_k$：</p>
<p>$\begin{align} \delta_k^T=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_k}}\\ =&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_k}}\\ =&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_{t-1}}}\frac{\partial{\mathrm{net}_{t-1}}}{\partial{\mathrm{net}_{t-2}}}…\frac{\partial{\mathrm{net}_{k+1}}}{\partial{\mathrm{net}_{k}}}\\ =&amp;Wdiag[f’(\mathrm{net}_{t-1})] Wdiag[f’(\mathrm{net}_{t-2})] … Wdiag[f’(\mathrm{net}_{k})] \delta_t^l\\ =&amp;\delta_t^T\prod_{i=k}^{t-1}Wdiag[f’(\mathrm{net}_{i})]\qquad(式3) \end {align}$</p>
<p><strong>式3</strong>就是将误差项沿时间反向传播的算法。</p>
<p><strong>循环层</strong>将<strong>误差项</strong>反向传递到上一层网络，与普通的<strong>全连接层</strong>是完全一样的，这在前面的文章<a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">零基础入门深度学习(3) - 神经网络和反向传播算法</a>中已经详细讲过了，在此仅简要描述一下。</p>
<p><strong>循环层</strong>的<strong>加权输入</strong>$\mathrm{net}^l$与上一层的<strong>加权输入</strong>$\mathrm{net}^{l-1}$关系如下：</p>
<p>$\begin{align} \mathrm{net}_t^l=&amp;U\mathrm{a}_t^{l-1}+W\mathrm{s}_{t-1}\\ \mathrm{a}_t^{l-1}=&amp;f^{l-1}(\mathrm{net}_t^{l-1}) \end {align}$</p>
<p>上式中$\mathrm{net}_t^l$是第$l$层神经元的<strong>加权输入</strong>(假设第l层是<strong>循环层</strong>)；$\mathrm{net}_t^{l-1}$是第$l-1$层神经元的<strong>加权输入</strong>；$\mathrm{a}_t^{l-1}$是第$l-1$层神经元的输出；$f^{l-1}$是第$l-1$层的<strong>激活函数</strong>。</p>
<p>$\begin{align} \frac{\partial{\mathrm{net}_t^l}}{\partial{\mathrm{net}_t^{l-1}}}=&amp;\frac{\partial{\mathrm{net}^l}}{\partial{\mathrm{a}_t^{l-1}}}\frac{\partial{\mathrm{a}_t^{l-1}}}{\partial{\mathrm{net}_t^{l-1}}}\\ =&amp;Udiag[f’^{l-1}(\mathrm{net}_t^{l-1})] \end {align}$</p>
<p>所以，</p>
<p>$\begin{align} (\delta_t^{l-1})^T=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t^{l-1}}}\\ =&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t^l}}\frac{\partial{\mathrm{net}_t^l}}{\partial{\mathrm{net}_t^{l-1}}}\\ =&amp;(\delta_t^l)^TUdiag[f’^{l-1}(\mathrm{net}_t^{l-1})]\qquad(式4) \end {align}$</p>
<p><strong>式4</strong>就是将误差项传递到上一层算法。</p>
<h4 id="权重梯度的计算"><a href="#权重梯度的计算" class="headerlink" title="权重梯度的计算"></a>权重梯度的计算</h4><p>现在，我们终于来到了BPTT算法的最后一步：计算每个权重的梯度$\frac{\partial{E}}{\partial{W}}$。</p>
<p>首先，我们计算误差函数E对权重矩阵W的梯度。</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-f7d034c8f05812f7.png)</p>
<p>上图展示了我们到目前为止，在前两步中已经计算得到的量，包括每个时刻t <strong>循环层</strong>的输出值$s_t$，以及误差项$\sigma_t$。</p>
<p>回忆一下我们在文章<a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">零基础入门深度学习(3) - 神经网络和反向传播算法</a>介绍的全连接网络的权重梯度计算算法：只要知道了任意一个时刻的<strong>误差项</strong>$\sigma_t$，以及上一个时刻循环层的输出值$s_{t-1}$，就可以按照下面的公式求出权重矩阵在$t$时刻的梯度$\nabla_{Wt}E$：</p>
<p>$\begin{align}\nabla_{W_t}E=\begin{bmatrix} \delta_1^ts_1^{t-1} &amp; \delta_1^ts_2^{t-1} &amp; … &amp;  \delta_1^ts_n^{t-1}\\ \delta_2^ts_1^{t-1} &amp; \delta_2^ts_2^{t-1} &amp; … &amp;  \delta_2^ts_n^{t-1}\\ .\.\\ \delta_n^ts_1^{t-1} &amp; \delta_n^ts_2^{t-1} &amp; … &amp;  \delta_n^ts_n^{t-1}\\ \end{bmatrix}\qquad(式5)\end {align}$</p>
<p>在<strong>式5</strong>中，$\delta_i^t$表示t时刻<strong>误差项</strong>向量的第$i$个分量；$s_i^{t-1}$表示$t-1$时刻<strong>循环层</strong>第$i$个神经元的输出值。</p>
<p>我们下面可以简单推导一下<strong>式5</strong>。</p>
<p>我们知道：</p>
<p>$\begin{align} \mathrm{net}_t=&amp;U\mathrm{x}_t+W\mathrm{s}_{t-1}\\ \begin{bmatrix} net_1^t\\ net_2^t\\ .\.\\ net_n^t\\ \end{bmatrix}=&amp;U\mathrm{x}_t+ \begin{bmatrix} w_{11} &amp; w_{12} &amp; … &amp; w_{1n}\\ w_{21} &amp; w_{22} &amp; … &amp; w_{2n}\\ .\.\\ w_{n1} &amp; w_{n2} &amp; … &amp; w_{nn}\\ \end{bmatrix} \begin{bmatrix} s_1^{t-1}\\ s_2^{t-1}\\ .\.\\ s_n^{t-1}\\ \end{bmatrix}\\ =&amp;U\mathrm{x}_t+ \begin{bmatrix} w_{11}s_1^{t-1}+w_{12}s_2^{t-1}…w_{1n}s_n^{t-1}\\ w_{21}s_1^{t-1}+w_{22}s_2^{t-1}…w_{2n}s_n^{t-1}\\ .\.\\ w_{n1}s_1^{t-1}+w_{n2}s_2^{t-1}…w_{nn}s_n^{t-1}\\ \end{bmatrix}\\ \end {align}$</p>
<p>因为对W求导与$U\mathrm{x}_t$无关，我们不再考虑。现在，我们考虑对权重项$w_{ji}$求导。通过观察上式我们可以看到$w_{ji}$只与$net_j^t$有关，所以：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{w_{ji}}}=&amp;\frac{\partial{E}}{\partial{net_j^t}}\frac{\partial{net_j^t}}{\partial{w_{ji}}}\\ =&amp;\delta_j^ts_i^{t-1} \end {align}$</p>
<p>按照上面的规律就可以生成<strong>式5</strong>里面的矩阵。</p>
<p>我们已经求得了权重矩阵W在t时刻的梯度$\nabla_{Wt}E$，最终的梯度$\nabla_WE$是各个时刻的梯度<strong>之和</strong>：</p>
<p>$\begin{align} \nabla_WE=&amp;\sum_{i=1}^t\nabla_{W_i}E\\ =&amp;\begin{bmatrix} \delta_1^ts_1^{t-1} &amp; \delta_1^ts_2^{t-1} &amp; … &amp;  \delta_1^ts_n^{t-1}\\ \delta_2^ts_1^{t-1} &amp; \delta_2^ts_2^{t-1} &amp; … &amp;  \delta_2^ts_n^{t-1}\\ .\.\\ \delta_n^ts_1^{t-1} &amp; \delta_n^ts_2^{t-1} &amp; … &amp;  \delta_n^ts_n^{t-1}\\ \end{bmatrix} +…+ \begin{bmatrix} \delta_1^1s_1^0 &amp; \delta_1^1s_2^0 &amp; … &amp;  \delta_1^1s_n^0\\ \delta_2^1s_1^0 &amp; \delta_2^1s_2^0 &amp; … &amp;  \delta_2^1s_n^0\\ .\.\\ \delta_n^1s_1^0 &amp; \delta_n^1s_2^0 &amp; … &amp;  \delta_n^1s_n^0\\ \end{bmatrix}\qquad(式6) \end{align} $</p>
<p><strong>式6</strong>就是计算<strong>循环层</strong>权重矩阵W的梯度的公式。</p>
<pre><code>----------数学公式超高能预警----------
</code></pre><p>前面已经介绍了$\nabla_WE$的计算方法，看上去还是比较直观的。然而，读者也许会困惑，为什么最终的梯度是各个时刻的梯度<strong>之和</strong>呢？我们前面只是直接用了这个结论，实际上这里面是有道理的，只是这个数学推导比较绕脑子。感兴趣的同学可以仔细阅读接下来这一段，它用到了矩阵对矩阵求导、张量与向量相乘运算的一些法则。</p>
<p>我们还是从这个式子开始：</p>
<p>$ \begin {align}\mathrm{net}_t=U\mathrm{x}_t+Wf(\mathrm{net}_{t-1}) \end {align} $</p>
<p>因为$U\mathrm{x}_t$与W完全无关，我们把它看做常量。现在，考虑第一个式子加号右边的部分，因为W和$f(\mathrm{net}_{t-1})$都是W的函数，因此我们要用到大学里面都学过的导数乘法运算：</p>
<p>$ \begin{align}(uv)’=u’v+uv’ \end {align}$</p>
<p>因此，上面第一个式子写成：</p>
<p>$ \begin{align} \frac{\partial{\mathrm{net}_t}}{\partial{W}}=\frac{\partial{W}}{\partial{W}}f(\mathrm{net}_{t-1})+W\frac{\partial{f(\mathrm{net}_{t-1})}}{\partial{W}}\\ \end{align} $</p>
<p>我们最终需要计算的是$\nabla_WE$：</p>
<p>$\begin{align} \nabla_WE=&amp;\frac{\partial{E}}{\partial{W}}\\ =&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}_t}}{\partial{W}}\\ =&amp;\delta_t^T\frac{\partial{W}}{\partial{W}}f(\mathrm{net}_{t-1})+ \delta_t^TW\frac{\partial{f(\mathrm{net}_{t-1})}}{\partial{W}}\qquad(式7)\\ \end{align} $</p>
<p>我们先计算<strong>式7</strong>加号左边的部分。$\frac{\partial{W}}{\partial{W}}$是<strong>矩阵对矩阵求导</strong>，其结果是一个四维<strong>张量(tensor)</strong>，如下所示：</p>
<p>$\begin{align} \frac{\partial{W}}{\partial{W}}=&amp; \begin{bmatrix} \frac{\partial{w_{11}}}{\partial{W}} &amp; \frac{\partial{w_{12}}}{\partial{W}} &amp; … &amp; \frac{\partial{w_{1n}}}{\partial{W}}\\ \frac{\partial{w_{21}}}{\partial{W}} &amp; \frac{\partial{w_{22}}}{\partial{W}} &amp; … &amp; \frac{\partial{w_{2n}}}{\partial{W}}\\ .\.\\ \frac{\partial{w_{n1}}}{\partial{W}} &amp; \frac{\partial{w_{n2}}}{\partial{W}} &amp; … &amp; \frac{\partial{w_{nn}}}{\partial{W}}\\ \end{bmatrix}\\ =&amp; \begin{bmatrix} \begin{bmatrix} \frac{\partial{w_{11}}}{\partial{w_{11}}} &amp; \frac{\partial{w_{11}}}{\partial{w_{12}}} &amp; … &amp; \frac{\partial{w_{11}}}{\partial{_{1n}}}\\ \frac{\partial{w_{11}}}{\partial{w_{21}}} &amp; \frac{\partial{w_{11}}}{\partial{w_{22}}} &amp; … &amp; \frac{\partial{w_{11}}}{\partial{_{2n}}}\\ .\.\\ \frac{\partial{w_{11}}}{\partial{w_{n1}}} &amp; \frac{\partial{w_{11}}}{\partial{w_{n2}}} &amp; … &amp; \frac{\partial{w_{11}}}{\partial{_{nn}}}\\ \end{bmatrix} &amp; \begin{bmatrix} \frac{\partial{w_{12}}}{\partial{w_{11}}} &amp; \frac{\partial{w_{12}}}{\partial{w_{12}}} &amp; … &amp; \frac{\partial{w_{12}}}{\partial{_{1n}}}\\ \frac{\partial{w_{12}}}{\partial{w_{21}}} &amp; \frac{\partial{w_{12}}}{\partial{w_{22}}} &amp; … &amp; \frac{\partial{w_{12}}}{\partial{_{2n}}}\\ .\.\\ \frac{\partial{w_{12}}}{\partial{w_{n1}}} &amp; \frac{\partial{w_{12}}}{\partial{w_{n2}}} &amp; … &amp; \frac{\partial{w_{12}}}{\partial{_{nn}}}\\ \end{bmatrix}&amp;…\\ .\.\\ \end{bmatrix}\\ =&amp; \begin{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; … &amp; 0\\ 0 &amp; 0 &amp; … &amp; 0\\ .\.\\ 0 &amp; 0 &amp; … &amp; 0\\ \end{bmatrix} &amp; \begin{bmatrix} 0 &amp; 1 &amp; … &amp; 0\\ 0 &amp; 0 &amp; … &amp; 0\\ .\.\\ 0 &amp; 0 &amp; … &amp; 0\\ \end{bmatrix}&amp;…\\ .\.\\ \end{bmatrix}\\ \end{align} $</p>
<p>接下来，我们知道$s_{t-1}=f({\mathrm{net}_{t-1}})$，它是一个<strong>列向量</strong>。我们让上面的四维张量与这个向量相乘，得到了一个三维张量，再左乘行向量$\delta_t^T$，最终得到一个矩阵：</p>
<p>$\begin{align} \delta_t^T\frac{\partial{W}}{\partial{W}}f({\mathrm{net}_{t-1}})=&amp; \delta_t^T\frac{\partial{W}}{\partial{W}}{\mathrm{s}_{t-1}}\\ =&amp;\delta_t^T \begin{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; … &amp; 0\\ 0 &amp; 0 &amp; … &amp; 0\\ .\.\\ 0 &amp; 0 &amp; … &amp; 0\\ \end{bmatrix} &amp; \begin{bmatrix} 0 &amp; 1 &amp; … &amp; 0\\ 0 &amp; 0 &amp; … &amp; 0\\ .\.\\ 0 &amp; 0 &amp; … &amp; 0\\ \end{bmatrix}&amp;…\\ .\.\\ \end{bmatrix} \begin{bmatrix} s_1^{t-1}\\ s_2^{t-1}\\ .\.\\ s_n^{t-1}\\ \end{bmatrix}\\ =&amp;\delta_t^T \begin{bmatrix} \begin{bmatrix} s_1^{t-1}\\ 0\\ .\.\\ 0\\ \end{bmatrix} &amp; \begin{bmatrix} s_2^{t-1}\\ 0\\ .\.\\ 0\\ \end{bmatrix}&amp;…\\ .\.\\ \end{bmatrix}\\ =&amp; \begin{bmatrix} \delta_1^t &amp; \delta_2^t &amp; … &amp;\delta_n^t \end{bmatrix} \begin{bmatrix} \begin{bmatrix} s_1^{t-1}\\ 0\\ .\.\\ 0\\ \end{bmatrix} &amp; \begin{bmatrix} s_2^{t-1}\\ 0\\ .\.\\ 0\\ \end{bmatrix}&amp;…\\ .\.\\ \end{bmatrix}\\ =&amp; \begin{bmatrix} \delta_1^ts_1^{t-1} &amp; \delta_1^ts_2^{t-1} &amp; … &amp;  \delta_1^ts_n^{t-1}\\ \delta_2^ts_1^{t-1} &amp; \delta_2^ts_2^{t-1} &amp; … &amp;  \delta_2^ts_n^{t-1}\\ .\.\\ \delta_n^ts_1^{t-1} &amp; \delta_n^ts_2^{t-1} &amp; … &amp;  \delta_n^ts_n^{t-1}\\ \end{bmatrix}\\ =&amp;\nabla_{Wt}E \end{align} $</p>
<p>接下来，我们计算<strong>式7</strong>加号右边的部分：</p>
<p>$\begin{align} \delta_t^TW\frac{\partial{f(\mathrm{net}_{t-1})}}{\partial{W}}=&amp; \delta_t^TW\frac{\partial{f(\mathrm{net}_{t-1})}}{\partial{\mathrm{net}_{t-1}}}\frac{\partial{\mathrm{net}_{t-1}}}{\partial{W}}\\ =&amp;\delta_t^TWf’(\mathrm{net}_{t-1})\frac{\partial{\mathrm{net}_{t-1}}}{\partial{W}}\\ =&amp;\delta_t^T\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_{t-1}}}\frac{\partial{\mathrm{net}_{t-1}}}{\partial{W}}\\ =&amp;\delta_{t-1}^T\frac{\partial{\mathrm{net}_{t-1}}}{\partial{W}}\\ \end{align} $</p>
<p>于是，我们得到了如下递推公式：</p>
<p>$\begin{align} \nabla_WE=&amp;\frac{\partial{E}}{\partial{W}}\\ =&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}_t}}{\partial{W}}\\ =&amp;\nabla_{Wt}E+\delta_{t-1}^T\frac{\partial{\mathrm{net}_{t-1}}}{\partial{W}}\\ =&amp;\nabla_{Wt}E+\nabla_{Wt-1}E+\delta_{t-2}^T\frac{\partial{\mathrm{net}_{t-2}}}{\partial{W}}\\ =&amp;\nabla_{Wt}E+\nabla_{Wt-1}E+…+\nabla_{W1}E\\ =&amp;\sum_{k=1}^t\nabla_{Wk}E \end{align} $</p>
<p>这样，我们就证明了：最终的梯度是各个时刻的梯度$\nabla_WE$之和。</p>
<pre><code>----------数学公式超高能预警解除----------
</code></pre><p>同权重矩阵W类似，我们可以得到权重矩阵U的计算方法。</p>
<p>$\begin{align}\nabla_{U_t}E=\begin{bmatrix} \delta_1^tx_1^t &amp; \delta_1^tx_2^t &amp; … &amp;  \delta_1^tx_m^t\\ \delta_2^tx_1^t &amp; \delta_2^tx_2^t &amp; … &amp;  \delta_2^tx_m^t\\ .\.\\ \delta_n^tx_1^t &amp; \delta_n^tx_2^t &amp; … &amp;  \delta_n^tx_m^t\\ \end{bmatrix}\qquad(式8) \end{align} $</p>
<p><strong>式8</strong>是误差函数在t时刻对权重矩阵U的梯度。和权重矩阵W一样，最终的梯度也是各个时刻的梯度之和：</p>
<p>$\begin{align}\nabla_UE=\sum_{i=1}^t\nabla_{U_i}E \end{align} $</p>
<p>具体的证明这里就不再赘述了，感兴趣的读者可以练习推导一下。</p>
<h3 id="RNN的梯度爆炸和消失问题"><a href="#RNN的梯度爆炸和消失问题" class="headerlink" title="RNN的梯度爆炸和消失问题"></a>RNN的梯度爆炸和消失问题</h3><p>不幸的是，实践中前面介绍的几种RNNs并不能很好的处理较长的序列。一个主要的原因是，RNN在训练中很容易发生<strong>梯度爆炸</strong>和<strong>梯度消失</strong>，这导致训练时梯度不能在较长序列中一直传递下去，从而使RNN无法捕捉到长距离的影响。</p>
<p>为什么RNN会产生梯度爆炸和消失问题呢？我们接下来将详细分析一下原因。我们根据<strong>式3</strong>可得：</p>
<p>$\begin{align} \delta_k^T=&amp;\delta_t^T\prod_{i=k}^{t-1}Wdiag[f’(\mathrm{net}_{i})]\\ |\delta_k^T|\leqslant&amp;|\delta_t^T|\prod_{i=k}^{t-1}|W||diag[f’(\mathrm{net}_{i})]|\\ \leqslant&amp;|\delta_t^T|(\beta_W\beta_f)^{t-k} \end{align} $</p>
<p>上式的$\beta$定义为矩阵的模的上界。因为上式是一个指数函数，如果t-k很大的话（也就是向前看很远的时候），会导致对应的<strong>误差项</strong>的值增长或缩小的非常快，这样就会导致相应的<strong>梯度爆炸</strong>和<strong>梯度消失</strong>问题（取决于大$\beta$于1还是小于1）。</p>
<p>通常来说，<strong>梯度爆炸</strong>更容易处理一些。因为梯度爆炸的时候，我们的程序会收到NaN错误。我们也可以设置一个梯度阈值，当梯度超过这个阈值的时候可以直接截取。</p>
<p><strong>梯度消失</strong>更难检测，而且也更难处理一些。总的来说，我们有三种方法应对梯度消失问题：</p>
<ol>
<li>合理的初始化权重值。初始化权重，使每个神经元尽可能不要取极大或极小值，以躲开梯度消失的区域。</li>
<li>使用relu代替sigmoid和tanh作为激活函数。原理请参考上一篇文章<a href="https://www.zybuluo.com/hanbingtao/note/485480" target="_blank" rel="noopener">零基础入门深度学习(4) - 卷积神经网络</a>的<strong>激活函数</strong>一节。</li>
<li>使用其他结构的RNNs，比如长短时记忆网络（LTSM）和Gated Recurrent Unit（GRU），这是最流行的做法。我们将在以后的文章中介绍这两种网络。</li>
</ol>
<h2 id="RNN的应用举例——基于RNN的语言模型"><a href="#RNN的应用举例——基于RNN的语言模型" class="headerlink" title="RNN的应用举例——基于RNN的语言模型"></a>RNN的应用举例——基于RNN的语言模型</h2><p>现在，我们介绍一下基于RNN语言模型。我们首先把词依次输入到循环神经网络中，每输入一个词，循环神经网络就输出截止到目前为止，下一个最可能的词。例如，当我们依次输入：</p>
<blockquote>
<p>我 昨天 上学 迟到 了</p>
</blockquote>
<p>神经网络的输出如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-a69765380a75f860.png)</p>
<p>其中，s和e是两个特殊的词，分别表示一个序列的开始和结束。</p>
<h3 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h3><p>我们知道，神经网络的输入和输出都是<strong>向量</strong>，为了让语言模型能够被神经网络处理，我们必须把词表达为向量的形式，这样神经网络才能处理它。</p>
<p>神经网络的输入是<strong>词</strong>，我们可以用下面的步骤对输入进行<strong>向量化</strong>：</p>
<ol>
<li>建立一个包含所有词的词典，每个词在词典里面有一个唯一的编号。</li>
<li>任意一个词都可以用一个N维的one-hot向量来表示。其中，N是词典中包含的词的个数。假设一个词在词典中的编号是i，v是表示这个词的向量，$v_j$是向量的第j个元素，则：</li>
</ol>
<p>$v_j=\begin{equation}\begin{cases}1\qquad j=i\\0\qquad j\ne i\end{cases}\end{equation} $</p>
<p>上面这个公式的含义，可以用下面的图来直观的表示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-14ae8b4f92e90c5c.png)</p>
<p>使用这种向量化方法，我们就得到了一个高维、<strong>稀疏</strong>的向量（稀疏是指绝大部分元素的值都是0）。处理这样的向量会导致我们的神经网络有很多的参数，带来庞大的计算量。因此，往往会需要使用一些降维方法，将高维的稀疏向量转变为低维的稠密向量。不过这个话题我们就不再这篇文章中讨论了。</p>
<p>语言模型要求的输出是下一个最可能的词，我们可以让循环神经网络计算计算词典中每个词是下一个词的概率，这样，概率最大的词就是下一个最可能的词。因此，神经网络的输出向量也是一个N维向量，向量中的每个元素对应着词典中相应的词是下一个词的概率。如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-3e1562c7031309f1.png)</p>
<h3 id="Softmax层"><a href="#Softmax层" class="headerlink" title="Softmax层"></a>Softmax层</h3><p>前面提到，<strong>语言模型</strong>是对下一个词出现的<strong>概率</strong>进行建模。那么，怎样让神经网络输出概率呢？方法就是用softmax层作为神经网络的输出层。</p>
<p>我们先来看一下softmax函数的定义：</p>
<p>$\begin{align} g(z_i)=\frac{e^{z_i}}{\sum_{k}e^{z_k}} \end{align}$</p>
<p>这个公式看起来可能很晕，我们举一个例子。Softmax层如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-5a3219fab80ab45f.png)</p>
<p>从上图我们可以看到，softmax layer的输入是一个向量，输出也是一个向量，两个向量的维度是一样的（在这个例子里面是4）。输入向量x=[1 2 3 4]经过softmax层之后，经过上面的softmax函数计算，转变为输出向量y=[0.03 0.09 0.24 0.64]。计算过程为：</p>
<p>$\begin{align} y_1&amp;=\frac{e^{x_1}}{\sum_{k}e^{x_k}}\\ &amp;=\frac{e^1}{e^1+e^2+e^3+e^4}\\ &amp;=0.03\\ y_2&amp;=\frac{e^2}{e^1+e^2+e^3+e^4}\\ &amp;=0.09\\ y_3&amp;=\frac{e^3}{e^1+e^2+e^3+e^4}\\ &amp;=0.24\\ y_4&amp;=\frac{e^4}{e^1+e^2+e^3+e^4}\\ &amp;=0.64\\ \end{align} $</p>
<p>我们来看看输出向量y的特征：</p>
<ol>
<li>每一项为取值为0-1之间的正数；</li>
<li>所有项的总和是1。</li>
</ol>
<p>我们不难发现，这些特征和<strong>概率</strong>的特征是一样的，因此我们可以把它们看做是概率。对于<strong>语言模型</strong>来说，我们可以认为模型预测下一个词是词典中第一个词的概率是0.03，是词典中第二个词的概率是0.09，以此类推。</p>
<h3 id="语言模型的训练"><a href="#语言模型的训练" class="headerlink" title="语言模型的训练"></a>语言模型的训练</h3><p>可以使用<strong>监督学习</strong>的方法对语言模型进行训练，首先，需要准备训练数据集。接下来，我们介绍怎样把语料</p>
<blockquote>
<p>我 昨天 上学 迟到 了</p>
</blockquote>
<p>转换成语言模型的训练数据集。</p>
<p>首先，我们获取<strong>输入-标签</strong>对：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">输入</th>
<th style="text-align:center">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">我</td>
</tr>
<tr>
<td style="text-align:center">我</td>
<td style="text-align:center">昨天</td>
</tr>
<tr>
<td style="text-align:center">昨天</td>
<td style="text-align:center">上学</td>
</tr>
<tr>
<td style="text-align:center">上学</td>
<td style="text-align:center">迟到</td>
</tr>
<tr>
<td style="text-align:center">迟到</td>
<td style="text-align:center">了</td>
</tr>
<tr>
<td style="text-align:center">了</td>
<td style="text-align:center">e</td>
</tr>
</tbody>
</table>
</div>
<p>然后，使用前面介绍过的<strong>向量化</strong>方法，对输入x和标签y进行<strong>向量化</strong>。这里面有意思的是，对标签y进行向量化，其结果也是一个one-hot向量。例如，我们对标签『我』进行向量化，得到的向量中，只有第2019个元素的值是1，其他位置的元素的值都是0。它的含义就是下一个词是『我』的概率是1，是其它词的概率都是0。</p>
<p>最后，我们使用<strong>交叉熵误差函数</strong>作为优化目标，对模型进行优化。</p>
<p>在实际工程中，我们可以使用大量的语料来对模型进行训练，获取训练数据和训练的方法都是相同的。</p>
<h3 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h3><p>一般来说，当神经网络的输出层是softmax层时，对应的误差函数E通常选择交叉熵误差函数，其定义如下：</p>
<p>$\begin{align} L(y,o)=-\frac{1}{N}\sum_{n\in{N}}{y_nlogo_n}  \end{align}$</p>
<p>在上式中，N是训练样本的个数，向量$y_n$是样本的标记，向量$o_n$是网络的输出。标记$y_n$是一个one-hot向量，例如$y_1=[1,0,0,0]$，如果网络的输出$o=[0.03,0.09,0.24,0.64]$，那么，交叉熵误差是（假设只有一个训练样本，即N=1）：</p>
<p>$\begin{align} L&amp;=-\frac{1}{N}\sum_{n\in{N}}{y_nlogo_n}\\ &amp;=-y_1logo_1\\ &amp;=-(1<em>log0.03+0</em>log0.09+0<em>log0.24+0</em>log0.64)\\ &amp;=3.51 \end{align} $</p>
<p>我们当然可以选择其他函数作为我们的误差函数，比如最小平方误差函数(MSE)。不过对概率进行建模时，选择交叉熵误差函数更make sense。具体原因，感兴趣的读者请阅读<a href="https://jamesmccaffrey.wordpress.com/2011/12/17/neural-network-classification-categorical-data-softmax-activation-and-cross-entropy-error/" target="_blank" rel="noopener">参考文献7</a>。</p>
<h2 id="RNN的实现"><a href="#RNN的实现" class="headerlink" title="RNN的实现"></a>RNN的实现</h2><blockquote>
<p>完整代码请参考GitHub: <a href="https://github.com/hanbt/learn_dl/blob/master/rnn.py" target="_blank" rel="noopener">https://github.com/hanbt/learn_dl/blob/master/rnn.py</a> (python2.7)</p>
</blockquote>
<p>为了加深我们对前面介绍的知识的理解，我们来动手实现一个RNN层。我们复用了上一篇文章<a href="https://www.zybuluo.com/hanbingtao/note/485480" target="_blank" rel="noopener">零基础入门深度学习(4) - 卷积神经网络</a>中的一些代码，所以先把它们导入进来。</p>
<pre class=" language-lang-python"><code class="language-lang-python">import numpy as np
from cnn import ReluActivator, IdentityActivator, element_wise_op
</code></pre>
<p>我们用RecurrentLayer类来实现一个<strong>循环层</strong>。下面的代码是初始化一个循环层，可以在构造函数中设置卷积层的超参数。我们注意到，循环层有两个权重数组，U和W。</p>
<pre class=" language-lang-python"><code class="language-lang-python">class RecurrentLayer(object):
    def __init__(self, input_width, state_width,
                 activator, learning_rate):
        self.input_width = input_width
        self.state_width = state_width
        self.activator = activator
        self.learning_rate = learning_rate
        self.times = 0       # 当前时刻初始化为t0
        self.state_list = [] # 保存各个时刻的state
        self.state_list.append(np.zeros(
            (state_width, 1)))           # 初始化s0
        self.U = np.random.uniform(-1e-4, 1e-4,
            (state_width, input_width))  # 初始化U
        self.W = np.random.uniform(-1e-4, 1e-4,
            (state_width, state_width))  # 初始化W
</code></pre>
<p>在forward方法中，实现循环层的前向计算，这部分比较简单。</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def forward(self, input_array):
        '''
        根据『式2』进行前向计算
        '''
        self.times += 1
        state = (np.dot(self.U, input_array) +
                 np.dot(self.W, self.state_list[-1]))
        element_wise_op(state, self.activator.forward)
        self.state_list.append(state)
</code></pre>
<p>在backword方法中，实现BPTT算法。</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def backward(self, sensitivity_array, 
                     activator):
            '''
            实现BPTT算法
            '''
            self.calc_delta(sensitivity_array, activator)
            self.calc_gradient()
    def calc_delta(self, sensitivity_array, activator):
        self.delta_list = []  # 用来保存各个时刻的误差项
        for i in range(self.times):
            self.delta_list.append(np.zeros(
                (self.state_width, 1)))
        self.delta_list.append(sensitivity_array)
        # 迭代计算每个时刻的误差项
        for k in range(self.times - 1, 0, -1):
            self.calc_delta_k(k, activator)
    def calc_delta_k(self, k, activator):
        '''
        根据k+1时刻的delta计算k时刻的delta
        '''
        state = self.state_list[k+1].copy()
        element_wise_op(self.state_list[k+1],
                    activator.backward)
        self.delta_list[k] = np.dot(
            np.dot(self.delta_list[k+1].T, self.W),
            np.diag(state[:,0])).T
    def calc_gradient(self):
        self.gradient_list = [] # 保存各个时刻的权重梯度
        for t in range(self.times + 1):
            self.gradient_list.append(np.zeros(
                (self.state_width, self.state_width)))
        for t in range(self.times, 0, -1):
            self.calc_gradient_t(t)
        # 实际的梯度是各个时刻梯度之和
        self.gradient = reduce(
            lambda a, b: a + b, self.gradient_list,
            self.gradient_list[0]) # [0]被初始化为0且没有被修改过
    def calc_gradient_t(self, t):
        '''
        计算每个时刻t权重的梯度
        '''
        gradient = np.dot(self.delta_list[t],
            self.state_list[t-1].T)
        self.gradient_list[t] = gradient
</code></pre>
<p>有意思的是，BPTT算法虽然数学推导的过程很麻烦，但是写成代码却并不复杂。</p>
<p>在update方法中，实现梯度下降算法。</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def update(self):
        '''
        按照梯度下降，更新权重
        '''
        self.W -= self.learning_rate * self.gradient
</code></pre>
<p>上面的代码不包含权重U的更新。这部分实际上和全连接神经网络是一样的，留给感兴趣的读者自己来完成吧。</p>
<p><strong>循环层</strong>是一个<strong>带状态</strong>的层，每次forword都会改变循环层的内部状态，这给梯度检查带来了麻烦。因此，我们需要一个reset_state方法，来重置循环层的内部状态。</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def reset_state(self):
        self.times = 0       # 当前时刻初始化为t0
        self.state_list = [] # 保存各个时刻的state
        self.state_list.append(np.zeros(
            (self.state_width, 1)))      # 初始化s0
</code></pre>
<p>最后，是梯度检查的代码。</p>
<pre class=" language-lang-python"><code class="language-lang-python">def gradient_check():
    '''
    梯度检查
    '''
    # 设计一个误差函数，取所有节点输出项之和
    error_function = lambda o: o.sum()
    rl = RecurrentLayer(3, 2, IdentityActivator(), 1e-3)
    # 计算forward值
    x, d = data_set()
    rl.forward(x[0])
    rl.forward(x[1])
    # 求取sensitivity map
    sensitivity_array = np.ones(rl.state_list[-1].shape,
                                dtype=np.float64)
    # 计算梯度
    rl.backward(sensitivity_array, IdentityActivator())
    # 检查梯度
    epsilon = 10e-4
    for i in range(rl.W.shape[0]):
        for j in range(rl.W.shape[1]):
            rl.W[i,j] += epsilon
            rl.reset_state()
            rl.forward(x[0])
            rl.forward(x[1])
            err1 = error_function(rl.state_list[-1])
            rl.W[i,j] -= 2*epsilon
            rl.reset_state()
            rl.forward(x[0])
            rl.forward(x[1])
            err2 = error_function(rl.state_list[-1])
            expect_grad = (err1 - err2) / (2 * epsilon)
            rl.W[i,j] += epsilon
            print 'weights(%d,%d): expected - actural %f - %f' % (
                i, j, expect_grad, rl.gradient[i,j])
</code></pre>
<p>需要注意，每次计算error之前，都要调用reset_state方法重置循环层的内部状态。下面是梯度检查的结果，没问题！</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-1bdfa618b5dbaabd.png)</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>至此，我们讲完了基本的<strong>循环神经网络</strong>、它的训练算法：<strong>BPTT</strong>，以及在语言模型上的应用。RNN比较烧脑，相信拿下前几篇文章的读者们搞定这篇文章也不在话下吧！然而，<strong>循环神经网络</strong>这个话题并没有完结。我们在前面说到过，基本的循环神经网络存在梯度爆炸和梯度消失问题，并不能真正的处理好长距离的依赖（虽然有一些技巧可以减轻这些问题）。事实上，真正得到广泛的应用的是循环神经网络的一个变体：<strong>长短时记忆网络</strong>。它内部有一些特殊的结构，可以很好的处理长距离的依赖，我们将在下一篇文章中详细的介绍它。现在，让我们稍事休息，准备挑战更为烧脑的<strong>长短时记忆网络</strong>吧。</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(5" alt="img">%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2256672-253fd3d6688ea73e.jpg)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">RECURRENT NEURAL NETWORKS TUTORIAL</a></li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li>
<li><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks</a></li>
<li><a href="http://distill.pub/2016/augmented-rnns/" target="_blank" rel="noopener">Attention and Augmented Recurrent Neural Networks</a></li>
<li><a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks, Bengio et al.</a></li>
<li><a href="http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf" target="_blank" rel="noopener">Recurrent neural network based language model, Mikolov et al.</a></li>
<li><a href="https://jamesmccaffrey.wordpress.com/2011/12/17/neural-network-classification-categorical-data-softmax-activation-and-cross-entropy-error/" target="_blank" rel="noopener">Neural Network Classification, Categorical Data, Softmax Activation, and Cross Entropy Error, McCaffrey</a></li>
</ol>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lunyang.github.io" rel="external nofollow noreferrer">lunyang</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lunyang.github.io">https://lunyang.github.io</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://lunyang.github.io" target="_blank">lunyang</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="../ling-ji-chu-ru-men-shen-du-xue-xi-7-di-gui-shen-jing-wang-luo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="零基础入门深度学习-递归神经网络">
                        
                        <span class="card-title">零基础入门深度学习-递归神经网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            参考链接：https://www.zybuluo.com/hanbingtao/note/626300

往期回顾在前面的文章中，我们介绍了循环神经网络，它可以用来处理包含序列结构的信息。然而，除此之外，信息往往还存在着诸如树结构、图结构等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-12-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="../categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    深度学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="../ling-ji-chu-ru-men-shen-du-xue-xi-6-chang-duan-shi-ji-yi-wang-luo-lstm/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="零基础入门深度学习-长短时记忆网络">
                        
                        <span class="card-title">零基础入门深度学习-长短时记忆网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            参考资料：https://www.zybuluo.com/hanbingtao/note/581764

往期回顾在上一篇文章中，我们介绍了循环神经网络以及它的训练算法。我们也介绍了循环神经网络很难训练的原因，这导致了它在实际应用中，很难处
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-12-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="../categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    深度学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://lunyang.github.io" target="_blank">lunyang</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:53917181@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="../atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
