<!DOCTYPE HTML>
<html lang="zh_CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="零基础入门深度学习-长短时记忆网络, Matter">
    <meta name="description" content="参考资料：https://www.zybuluo.com/hanbingtao/note/581764

往期回顾在上一篇文章中，我们介绍了循环神经网络以及它的训练算法。我们也介绍了循环神经网络很难训练的原因，这导致了它在实际应用中，很难处">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>零基础入门深度学习-长短时记忆网络 | Matter</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="../index.html" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Matter</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>文章分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Matter</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			文章分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">零基础入门深度学习-长短时记忆网络</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="../categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                深度学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2019-12-20
                </div>
                

                

                

                

                
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>参考资料：<a href="https://www.zybuluo.com/hanbingtao/note/581764" target="_blank" rel="noopener">https://www.zybuluo.com/hanbingtao/note/581764</a></p>
<hr>
<h2 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h2><p>在上一篇文章中，我们介绍了<strong>循环神经网络</strong>以及它的训练算法。我们也介绍了<strong>循环神经网络</strong>很难训练的原因，这导致了它在实际应用中，很难处理长距离的依赖。在本文中，我们将介绍一种改进之后的循环神经网络：<strong>长短时记忆网络(Long Short Term Memory Network, LSTM)</strong>，它成功的解决了原始循环神经网络的缺陷，成为当前最流行的RNN，在语音识别、图片描述、自然语言处理等许多领域中成功应用。但不幸的一面是，<strong>LSTM</strong>的结构很复杂，因此，我们需要花上一些力气，才能把LSTM以及它的训练算法弄明白。在搞清楚<strong>LSTM</strong>之后，我们再介绍一种<strong>LSTM</strong>的变体：<strong>GRU (Gated Recurrent Unit)</strong>。 它的结构比<strong>LSTM</strong>简单，而效果却和<strong>LSTM</strong>一样好，因此，它正在逐渐流行起来。最后，我们仍然会动手实现一个<strong>LSTM</strong>。</p>
<h2 id="长短时记忆网络是啥"><a href="#长短时记忆网络是啥" class="headerlink" title="长短时记忆网络是啥"></a>长短时记忆网络是啥</h2><p>我们首先了解一下长短时记忆网络产生的背景。回顾一下<a href="https://zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习(5) - 循环神经网络</a>中推导的，误差项沿时间反向传播的公式：</p>
<p>$\begin{align} \delta_k^T=&amp;\delta_t^T\prod_{i=k}^{t-1}diag[f’(\mathbf{net}_{i})]W\\ \end{align} $</p>
<p>我们可以根据下面的不等式，来获取$\delta_k^T$的模的上界（模可以看做对$\delta_k^T$中每一项值的大小的度量）：</p>
<p>$\begin{align} |\delta_k^T|\leqslant&amp;|\delta_t^T|\prod_{i=k}^{t-1}|diag[f’(\mathbf{net}_{i})]||W|\\ \leqslant&amp;|\delta_t^T|(\beta_f\beta_W)^{t-k} \end{align} $</p>
<p>我们可以看到，误差项$\delta$从t时刻传递到k时刻，其值的上界是$\beta_f\beta_w$的指数函数。$\beta_f\beta_w$分别是对角矩阵$diag[f’(\mathbf{net}_{i})]$和矩阵W模的上界。显然，除非乘积的值位于1附近，否则，当t-k很大时（也就是误差传递很多个时刻时），整个式子的值就会变得极小（当$\beta_f\beta_w$乘积小于1）或者极大（当$\beta_f\beta_w$乘积大于1），前者就是<strong>梯度消失</strong>，后者就是<strong>梯度爆炸</strong>。虽然科学家们搞出了很多技巧（比如怎样初始化权重），让$\beta_f\beta_w$的值尽可能贴近于1，终究还是难以抵挡指数函数的威力。</p>
<p><strong>梯度消失</strong>到底意味着什么？在<a href="https://zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习(5) - 循环神经网络</a>中我们已证明，权重数组W最终的梯度是各个时刻的梯度之和，即：</p>
<p>$\begin{align} \nabla_WE&amp;=\sum_{k=1}^t\nabla_{Wk}E\\ &amp;=\nabla_{Wt}E+\nabla_{Wt-1}E+\nabla_{Wt-2}E+…+\nabla_{W1}E \end{align} $</p>
<p>假设某轮训练中，各时刻的梯度以及最终的梯度之和如下图：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-48784f6366412472.png)</p>
<p>我们就可以看到，从上图的t-3时刻开始，梯度已经几乎减少到0了。那么，从这个时刻开始再往之前走，得到的梯度（几乎为零）就不会对最终的梯度值有任何贡献，这就相当于无论t-3时刻之前的网络状态h是什么，在训练中都不会对权重数组W的更新产生影响，也就是网络事实上已经忽略了t-3时刻之前的状态。这就是原始RNN无法处理长距离依赖的原因。</p>
<p>既然找到了问题的原因，那么我们就能解决它。从问题的定位到解决，科学家们大概花了7、8年时间。终于有一天，Hochreiter和Schmidhuber两位科学家发明出<strong>长短时记忆网络</strong>，一举解决这个问题。</p>
<p>其实，<strong>长短时记忆网络</strong>的思路比较简单。原始RNN的隐藏层只有一个状态，即h，它对于短期的输入非常敏感。那么，假如我们再增加一个状态，即c，让它来保存长期的状态，那么问题不就解决了么？如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-71de4194da5a5ec4.png)</p>
<p>新增加的状态c，称为<strong>单元状态(cell state)</strong>。我们把上图按照时间维度展开：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-715658c134b9d6f1.png)</p>
<p>上图仅仅是一个示意图，我们可以看出，在t时刻，LSTM的输入有三个：当前时刻网络的输入值$\mathbf{x}_t$、上一时刻LSTM的输出值$\mathbf{h}_{t-1}$、以及上一时刻的单元状态$\mathbf{c}_{t-1}$；LSTM的输出有两个：当前时刻LSTM输出值$\mathbf{h}_t$、和当前时刻的单元状态$\mathbf{c}_t$。注意$\mathbf{x}$、$\mathbf{h}$、$\mathbf{c}$都是<strong>向量</strong>。</p>
<p>LSTM的关键，就是怎样控制长期状态c。在这里，LSTM的思路是使用三个控制开关。第一个开关，负责控制继续保存长期状态c；第二个开关，负责控制把即时状态输入到长期状态c；第三个开关，负责控制是否把长期状态c作为当前的LSTM的输出。三个开关的作用如下图所示：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-bff9353b92b9c488.png)</p>
<p>接下来，我们要描述一下，输出h和单元状态c的具体计算方法。</p>
<h2 id="长短时记忆网络的前向计算"><a href="#长短时记忆网络的前向计算" class="headerlink" title="长短时记忆网络的前向计算"></a>长短时记忆网络的前向计算</h2><p>前面描述的开关是怎样在算法中实现的呢？这就用到了<strong>门（gate）</strong>的概念。门实际上就是一层<strong>全连接层</strong>，它的输入是一个向量，输出是一个0到1之间的实数向量。假设W是门的权重向量，是偏置项，那么门可以表示为：</p>
<p>$\begin{align}g(\mathbf{x})=\sigma(W\mathbf{x}+\mathbf{b}) \end{align} $</p>
<p>门的使用，就是用门的输出向量按元素乘以我们需要控制的那个向量。因为门的输出是0到1之间的实数向量，那么，当门输出为0时，任何向量与之相乘都会得到0向量，这就相当于啥都不能通过；输出为1时，任何向量与之相乘都不会有任何改变，这就相当于啥都可以通过。因为$\sigma$（也就是sigmoid函数）的值域是(0,1)，所以门的状态都是半开半闭的。</p>
<p>LSTM用两个门来控制单元状态c的内容，一个是<strong>遗忘门（forget gate）</strong>，它决定了上一时刻的单元状态$\mathbf{c}_{t-1}$有多少保留到当前时刻$\mathbf{c}_{t}$；另一个是<strong>输入门（input gate）</strong>，它决定了当前时刻网络的输入$\mathbf{x}_t$有多少保存到单元状态$\mathbf{c}_t$。LSTM用<strong>输出门（output gate）</strong>来控制单元状态$\mathbf{c}_t$有多少输出到LSTM的当前输出值$\mathbf{h}_t$。</p>
<p>我们先来看一下遗忘门：</p>
<p>$\begin{align}\mathbf{f}_t=\sigma(W_f\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_f)\qquad\quad(式1) \end{align} $</p>
<p>上式中，$W_f$是遗忘门的权重矩阵，$[\mathbf{h}_{t-1},\mathbf{x}_t]$表示把两个向量连接成一个更长的向量，$\mathbf{b}_f$是遗忘门的偏置项，$\sigma$是sigmoid函数。如果输入的维度是$d_x$，隐藏层的维度是$d_h$，单元状态的维度是$d_c$（通常$d_c=d_h$），则遗忘门的权重矩阵$W_f$维度是$d_c\times (d_h+d_x)$。事实上，权重矩阵$W_f$都是两个矩阵拼接而成的：一个是$W_{fh}$，它对应着输入项$\mathbf{h}_{t-1}$，其维度为$d_c\times d_h$；一个是$W_{fx}$，它对应着输入项$\mathbf{x}_t$，其维度为$d_c\times d_x$。$W_f$可以写为：</p>
<p>$\begin{align} \begin{bmatrix}W_f\end{bmatrix}\begin{bmatrix}\mathbf{h}_{t-1}\\ \mathbf{x}_t\end{bmatrix}&amp;= \begin{bmatrix}W_{fh}&amp;W_{fx}\end{bmatrix}\begin{bmatrix}\mathbf{h}_{t-1}\\ \mathbf{x}_t\end{bmatrix}\\ &amp;=W_{fh}\mathbf{h}_{t-1}+W_{fx}\mathbf{x}_t \end{align} $</p>
<p>下图显示了遗忘门的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-c7f7ca0aa64b562f.png)</p>
<p>接下来看看输入门：</p>
<p>$\begin{align} \mathbf{i}_t=\sigma(W_i\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_i)\qquad\quad(式2) \end{align} $</p>
<p>上式中，是输入门的权重矩阵，是输入门的偏置项。下图表示了输入门的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-89529fa23d9c8a7d.png)</p>
<p>接下来，我们计算用于描述当前输入的单元状态$\mathbf{\tilde{c}}_t$，它是根据上一次的输出和本次输入来计算的：</p>
<p>$\begin{align} \mathbf{\tilde{c}}_t=\tanh(W_c\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_c)\qquad\quad(式3) \end{align} $</p>
<p>下图是$\mathbf{\tilde{c}}_t$的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-73a0246cafc1d10d.png)</p>
<p>现在，我们计算当前时刻的单元状态$\mathbf{\tilde{c}}_t$。它是由上一次的单元状态$\mathbf{\tilde{c}}_{t-1}$按元素乘以遗忘门$f_t$，再用当前输入的单元状态$\mathbf{\tilde{c}}_t$按元素乘以输入门$i_t$，再将两个积加和产生的：</p>
<p>$\begin{align} \mathbf{c}_t=f_t\circ{\mathbf{c}_{t-1}}+i_t\circ{\mathbf{\tilde{c}}_t}\qquad\quad(式4) \end{align} $</p>
<p>符号表示<strong>按元素乘</strong>。下图是$\mathbf{c}_t$的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-5c766f3d734334b1.png)</p>
<p>这样，我们就把LSTM关于当前的记忆$\mathbf{\tilde{c}}_t$和长期的记忆$\mathbf{\tilde{c}}_{t-1}$组合在一起，形成了新的单元状态$\mathbf{\tilde{c}}_t$。由于遗忘门的控制，它可以保存很久很久之前的信息，由于输入门的控制，它又可以避免当前无关紧要的内容进入记忆。下面，我们要看看输出门，它控制了长期记忆对当前输出的影响：</p>
<p>$\begin{align} \mathbf{o}_t=\sigma(W_o\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_o)\qquad\quad(式5)\end{align} $</p>
<p>下图表示输出门的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-fd4d91d1b68b3759.png)</p>
<p>LSTM最终的输出，是由输出门和单元状态共同确定的：</p>
<p>$\begin{align}\mathbf{h}_t=\mathbf{o}_t\circ \tanh(\mathbf{c}_t)\qquad\quad(式6)\end{align} $</p>
<p>下图表示LSTM最终输出的计算：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-7ea82e4f1ac6cd75.png)</p>
<p><strong>式1</strong>到<strong>式6</strong>就是LSTM前向计算的全部公式。至此，我们就把LSTM前向计算讲完了。</p>
<h2 id="长短时记忆网络的训练"><a href="#长短时记忆网络的训练" class="headerlink" title="长短时记忆网络的训练"></a>长短时记忆网络的训练</h2><p>熟悉我们这个系列文章的同学都清楚，训练部分往往比前向计算部分复杂多了。LSTM的前向计算都这么复杂，那么，可想而知，它的训练算法一定是非常非常复杂的。现在只有做几次深呼吸，再一头扎进公式海洋吧。</p>
<h3 id="LSTM训练算法框架"><a href="#LSTM训练算法框架" class="headerlink" title="LSTM训练算法框架"></a>LSTM训练算法框架</h3><p>LSTM的训练算法仍然是反向传播算法，对于这个算法，我们已经非常熟悉了。主要有下面三个步骤：</p>
<ol>
<li>前向计算每个神经元的输出值，对于LSTM来说，即$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{c}_t$、$\mathbf{o}_t$、$\mathbf{h}_t$五个向量的值。计算方法已经在上一节中描述过了。</li>
<li>反向计算每个神经元的<strong>误差项</strong>$\sigma $值。与<strong>循环神经网络</strong>一样，LSTM误差项的反向传播也是包括两个方向：一个是沿时间的反向传播，即从当前t时刻开始，计算每个时刻的误差项；一个是将误差项向上一层传播。</li>
<li>根据相应的误差项，计算每个权重的梯度。</li>
</ol>
<h3 id="关于公式和符号的说明"><a href="#关于公式和符号的说明" class="headerlink" title="关于公式和符号的说明"></a>关于公式和符号的说明</h3><p>首先，我们对推导中用到的一些公式、符号做一下必要的说明。</p>
<p>接下来的推导中，我们设定gate的激活函数为sigmoid函数，输出的激活函数为tanh函数。他们的导数分别为：</p>
<p>$\begin{align} \sigma(z)&amp;=y=\frac{1}{1+e^{-z}}\\ \sigma’(z)&amp;=y(1-y)\\ \tanh(z)&amp;=y=\frac{e^z-e^{-z}}{e^z+e^{-z}}\\ \tanh’(z)&amp;=1-y^2 \end{align} $</p>
<p>从上面可以看出，sigmoid和tanh函数的导数都是原函数的函数。这样，我们一旦计算原函数的值，就可以用它来计算出导数的值。</p>
<p>LSTM需要学习的参数共有8组，分别是：遗忘门的权重矩阵$W_f$和偏置项$\mathbf{b}_f$、输入门的权重矩阵$W_i$和偏置项$\mathbf{b}_i$、输出门的权重矩阵$W_o$和偏置项$\mathbf{b}_o$，以及计算单元状态的权重矩阵$W_c$和偏置项$\mathbf{b}_c$。因为权重矩阵的两部分在反向传播中使用不同的公式，因此在后续的推导中，权重矩阵$W_f$、$W_i$、$W_c$、$W_o$都将被写为分开的两个矩阵：$W_{fh}$、$W_{fx}$、$W_{ih}$、$W_{ix}$、$W_{oh}$、$W_{ox}$、$W_{ch}$、$W_{cx}$。</p>
<p>我们解释一下按元素乘$\circ$符号。当$\circ$作用于两个<strong>向量</strong>时，运算如下：</p>
<p>$\begin{align}\mathbf{a}\circ\mathbf{b}=\begin{bmatrix} a_1\\a_2\\a_3\...\\a_n \end{bmatrix}\circ\begin{bmatrix} b_1\\b_2\\b_3\...\\b_n \end{bmatrix}=\begin{bmatrix} a_1b_1\\a_2b_2\\a_3b_3\...\\a_nb_n \end{bmatrix} \end{align} $</p>
<p>当作用于一个<strong>向量</strong>和一个<strong>矩阵</strong>时，运算如下：</p>
<p>$\begin{align} \mathbf{a}\circ X&amp;=\begin{bmatrix} a_1\\a_2\\a_3\...\\a_n \end{bmatrix}\circ\begin{bmatrix} x_{11} &amp; x_{12} &amp; x_{13} &amp; … &amp; x_{1n}\\ x_{21} &amp; x_{22} &amp; x_{23} &amp; … &amp; x_{2n}\\ x_{31} &amp; x_{32} &amp; x_{33} &amp; … &amp; x_{3n}\\ &amp; &amp; …\\ x_{n1} &amp; x_{n2} &amp; x_{n3} &amp; … &amp; x_{nn}\\ \end{bmatrix}\\ &amp;=\begin{bmatrix} a_1x_{11} &amp; a_1x_{12} &amp; a_1x_{13} &amp; … &amp; a_1x_{1n}\\ a_2x_{21} &amp; a_2x_{22} &amp; a_2x_{23} &amp; … &amp; a_2x_{2n}\\ a_3x_{31} &amp; a_3x_{32} &amp; a_3x_{33} &amp; … &amp; a_3x_{3n}\\ &amp; &amp; …\\ a_nx_{n1} &amp; a_nx_{n2} &amp; a_nx_{n3} &amp; … &amp; a_nx_{nn}\\ \end{bmatrix} \end{align} $</p>
<p>当作用于两个<strong>矩阵</strong>时，两个矩阵对应位置的元素相乘。按元素乘可以在某些情况下简化矩阵和向量运算。例如，当一个对角矩阵右乘一个矩阵时，相当于用对角矩阵的对角线组成的向量按元素乘那个矩阵：</p>
<p>$\begin{align} diag[\mathbf{a}]X=\mathbf{a}\circ X \end{align}$</p>
<p>当一个行向量右乘一个对角矩阵时，相当于这个行向量按元素乘那个矩阵对角线组成的向量：</p>
<p>$\begin{align} \mathbf{a}^Tdiag[\mathbf{b}]=\mathbf{a}\circ\mathbf{b} \end{align} $</p>
<p>上面这两点，在我们后续推导中会多次用到。</p>
<p>在t时刻，LSTM的输出值为$\mathbf{h}_t$。我们定义t时刻的误差项$\delta_t$为：</p>
<p>$\begin{align}\delta_t\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{h}_t}} \end{align} $</p>
<p>注意，和前面几篇文章不同，我们这里假设误差项是损失函数对输出值的导数，而不是对加权输入$net_t^l$的导数。因为LSTM有四个加权输入，分别对应$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{c}_t$、$\mathbf{o}_t$，我们希望往上一层传递一个误差项而不是四个。但我们仍然需要定义出这四个加权输入，以及他们对应的误差项。</p>
<p>$\begin{align} \mathbf{net}_{f,t}&amp;=W_f[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_f\\ &amp;=W_{fh}\mathbf{h}_{t-1}+W_{fx}\mathbf{x}_t+\mathbf{b}_f\\ \mathbf{net}_{i,t}&amp;=W_i[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_i\\ &amp;=W_{ih}\mathbf{h}_{t-1}+W_{ix}\mathbf{x}_t+\mathbf{b}_i\\ \mathbf{net}_{\tilde{c},t}&amp;=W_c[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_c\\ &amp;=W_{ch}\mathbf{h}_{t-1}+W_{cx}\mathbf{x}_t+\mathbf{b}_c\\ \mathbf{net}_{o,t}&amp;=W_o[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_o\\ &amp;=W_{oh}\mathbf{h}_{t-1}+W_{ox}\mathbf{x}_t+\mathbf{b}_o\\ \delta_{f,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}_{f,t}}}\\ \delta_{i,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}_{i,t}}}\\ \delta_{\tilde{c},t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}_{\tilde{c},t}}}\\ \delta_{o,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}_{o,t}}}\\ \end{align} $</p>
<h3 id="误差项沿时间的反向传递"><a href="#误差项沿时间的反向传递" class="headerlink" title="误差项沿时间的反向传递"></a>误差项沿时间的反向传递</h3><p>沿时间反向传递误差项，就是要计算出t-1时刻的误差项$\sigma_{t-1}$。</p>
<p>$\begin{align} \delta_{t-1}^T&amp;=\frac{\partial{E}}{\partial{\mathbf{h_{t-1}}}}\\ &amp;=\frac{\partial{E}}{\partial{\mathbf{h_t}}}\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}}\\ &amp;=\delta_{t}^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}} \end{align} $</p>
<p>我们知道，$\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}}$是一个Jacobian矩阵。如果隐藏层h的维度是N的话，那么它就是一个$N\times N$矩阵。为了求出它，我们列出$\mathbf{h}_t$的计算公式，即前面的<strong>式6</strong>和<strong>式4</strong>：</p>
<p>$\begin{align} \mathbf{h}_t&amp;=\mathbf{o}_t\circ \tanh(\mathbf{c}_t)\\ \mathbf{c}_t&amp;=\mathbf{f}_t\circ\mathbf{c}_{t-1}+\mathbf{i}_t\circ\mathbf{\tilde{c}}_t \end{align} $</p>
<p>显然，$\mathbf{o}_t$、$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{\tilde{c}}_t$都是$\mathbf{h}_{t-1}$的函数，那么，利用全导数公式可得：</p>
<p>$\begin{align} \delta_t^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}}&amp;=\delta_t^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{o}_t}}\frac{\partial{\mathbf{o}_t}}{\partial{\mathbf{net}_{o,t}}}\frac{\partial{\mathbf{net}_{o,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_t^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{c}_t}}\frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{f_{t}}}}\frac{\partial{\mathbf{f}_t}}{\partial{\mathbf{net}_{f,t}}}\frac{\partial{\mathbf{net}_{f,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_t^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{c}_t}}\frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{i_{t}}}}\frac{\partial{\mathbf{i}_t}}{\partial{\mathbf{net}_{i,t}}}\frac{\partial{\mathbf{net}_{i,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_t^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{c}_t}}\frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{\tilde{c}}_{t}}}\frac{\partial{\mathbf{\tilde{c}}_t}}{\partial{\mathbf{net}_{\tilde{c},t}}}\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{\mathbf{h_{t-1}}}}\\ &amp;=\delta_{o,t}^T\frac{\partial{\mathbf{net}_{o,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{f,t}^T\frac{\partial{\mathbf{net}_{f,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{i,t}^T\frac{\partial{\mathbf{net}_{i,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{\tilde{c},t}^T\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{\mathbf{h_{t-1}}}}\qquad\quad(式7) \end{align} $</p>
<p>下面，我们要把<strong>式7</strong>中的每个偏导数都求出来。根据<strong>式6</strong>，我们可以求出：</p>
<p>$\begin{align} \frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{o}_t}}&amp;=diag[\tanh(\mathbf{c}_t)]\\ \frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{c}_t}}&amp;=diag[\mathbf{o}_t\circ(1-\tanh(\mathbf{c}_t)^2)] \end{align} $</p>
<p>根据<strong>式4</strong>，我们可以求出：</p>
<p>$\begin{align} \frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{f_{t}}}}&amp;=diag[\mathbf{c}_{t-1}]\\ \frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{i_{t}}}}&amp;=diag[\mathbf{\tilde{c}}_t]\\ \frac{\partial{\mathbf{c}_t}}{\partial{\mathbf{\tilde{c}_{t}}}}&amp;=diag[\mathbf{i}_t]\\ \end{align} $</p>
<p>因为：</p>
<p>$\begin{align} \mathbf{o}_t&amp;=\sigma(\mathbf{net}_{o,t})\\ \mathbf{net}_{o,t}&amp;=W_{oh}\mathbf{h}_{t-1}+W_{ox}\mathbf{x}_t+\mathbf{b}_o\\\\ \mathbf{f}_t&amp;=\sigma(\mathbf{net}_{f,t})\\ \mathbf{net}_{f,t}&amp;=W_{fh}\mathbf{h}_{t-1}+W_{fx}\mathbf{x}_t+\mathbf{b}_f\\\\ \mathbf{i}_t&amp;=\sigma(\mathbf{net}_{i,t})\\ \mathbf{net}_{i,t}&amp;=W_{ih}\mathbf{h}_{t-1}+W_{ix}\mathbf{x}_t+\mathbf{b}_i\\\\ \mathbf{\tilde{c}}_t&amp;=\tanh(\mathbf{net}_{\tilde{c},t})\\ \mathbf{net}_{\tilde{c},t}&amp;=W_{ch}\mathbf{h}_{t-1}+W_{cx}\mathbf{x}_t+\mathbf{b}_c\\ \end{align} $</p>
<p>我们很容易得出：</p>
<p>$\begin{align} \frac{\partial{\mathbf{o}_t}}{\partial{\mathbf{net}_{o,t}}}&amp;=diag[\mathbf{o}_t\circ(1-\mathbf{o}_t)]\\ \frac{\partial{\mathbf{net}_{o,t}}}{\partial{\mathbf{h_{t-1}}}}&amp;=W_{oh}\\ \frac{\partial{\mathbf{f}_t}}{\partial{\mathbf{net}_{f,t}}}&amp;=diag[\mathbf{f}_t\circ(1-\mathbf{f}_t)]\\ \frac{\partial{\mathbf{net}_{f,t}}}{\partial{\mathbf{h}_{t-1}}}&amp;=W_{fh}\\ \frac{\partial{\mathbf{i}_t}}{\partial{\mathbf{net}_{i,t}}}&amp;=diag[\mathbf{i}_t\circ(1-\mathbf{i}_t)]\\ \frac{\partial{\mathbf{net}_{i,t}}}{\partial{\mathbf{h}_{t-1}}}&amp;=W_{ih}\\ \frac{\partial{\mathbf{\tilde{c}}_t}}{\partial{\mathbf{net}_{\tilde{c},t}}}&amp;=diag[1-\mathbf{\tilde{c}}_t^2]\\ \frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{\mathbf{h}_{t-1}}}&amp;=W_{ch} \end{align} $</p>
<p>将上述偏导数带入到<strong>式7</strong>，我们得到：</p>
<p>$\begin{align} \delta_{t-1}&amp;=\delta_{o,t}^T\frac{\partial{\mathbf{net}_{o,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{f,t}^T\frac{\partial{\mathbf{net}_{f,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{i,t}^T\frac{\partial{\mathbf{net}_{i,t}}}{\partial{\mathbf{h_{t-1}}}} +\delta_{\tilde{c},t}^T\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{\mathbf{h_{t-1}}}}\\ &amp;=\delta_{o,t}^T W_{oh} +\delta_{f,t}^TW_{fh} +\delta_{i,t}^TW_{ih} +\delta_{\tilde{c},t}^TW_{ch}\qquad\quad(式8)\\ \end{align} $</p>
<p>根据$\delta_{o,t}$、$\delta_{f,t}$、$\delta_{i,t}$、$\delta_{\tilde{c},t}$的定义，可知：</p>
<p>$\begin{align} \delta_{o,t}^T&amp;=\delta_t^T\circ\tanh(\mathbf{c}_t)\circ\mathbf{o}_t\circ(1-\mathbf{o}_t)\qquad\quad(式9)\\ \delta_{f,t}^T&amp;=\delta_t^T\circ\mathbf{o}_t\circ(1-\tanh(\mathbf{c}_t)^2)\circ\mathbf{c}_{t-1}\circ\mathbf{f}_t\circ(1-\mathbf{f}_t)\qquad(式10)\\ \delta_{i,t}^T&amp;=\delta_t^T\circ\mathbf{o}_t\circ(1-\tanh(\mathbf{c}_t)^2)\circ\mathbf{\tilde{c}}_t\circ\mathbf{i}_t\circ(1-\mathbf{i}_t)\qquad\quad(式11)\\ \delta_{\tilde{c},t}^T&amp;=\delta_t^T\circ\mathbf{o}_t\circ(1-\tanh(\mathbf{c}_t)^2)\circ\mathbf{i}_t\circ(1-\mathbf{\tilde{c}}^2)\qquad\quad(式12)\\ \end{align} $</p>
<p><strong>式8</strong>到<strong>式12</strong>就是将误差沿时间反向传播一个时刻的公式。有了它，我们可以写出将误差项向前传递到任意k时刻的公式：</p>
<p>$\begin{align} \delta_k^T=\prod_{j=k}^{t-1}\delta_{o,j}^TW_{oh} +\delta_{f,j}^TW_{fh} +\delta_{i,j}^TW_{ih} +\delta_{\tilde{c},j}^TW_{ch}\qquad\quad(式13) \end{align}$</p>
<h3 id="将误差项传递到上一层"><a href="#将误差项传递到上一层" class="headerlink" title="将误差项传递到上一层"></a>将误差项传递到上一层</h3><p>我们假设当前为第l层，定义l-1层的误差项是误差函数对l-1层<strong>加权输入</strong>的导数，即：</p>
<p>$\begin {align} \delta_t^{l-1}\overset{def}{=}\frac{\partial{E}}{\mathbf{net}_t^{l-1}} \end {align} $</p>
<p>本次LSTM的输入$x_t$由下面的公式计算：</p>
<p>$\begin {align} \mathbf{x}_t^l=f^{l-1}(\mathbf{net}_t^{l-1}) \end{align} $</p>
<p>上式中，$f^{l-1}$表示第l-1层的<strong>激活函数</strong>。</p>
<p>因为$\mathbf{net}_{f,t}^l$、$\mathbf{net}_{i,t}^l$、$\mathbf{net}_{\tilde{c},t}^l$、$\mathbf{net}_{o,t}^l$都是$\mathbf{x}_t$的函数，$\mathbf{x}_t$又是$\mathbf{net}_t^{l-1}$的函数，因此，要求出E对$\mathbf{net}_t^{l-1}$的导数，就需要使用全导数公式：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{\mathbf{net}_t^{l-1}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}_{f,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{f,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}_t^{l-1}}}} +\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}_{i,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{i,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}_t^{l-1}}}} +\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}_{\tilde{c},t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{\tilde{c},t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}_t^{l-1}}}} +\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}_{o,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{o,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}_t^{l-1}}}}\\ &amp;=\delta_{f,t}^TW_{fx}\circ f’(\mathbf{net}_t^{l-1})+\delta_{i,t}^TW_{ix}\circ f’(\mathbf{net}_t^{l-1})+\delta_{\tilde{c},t}^TW_{cx}\circ f’(\mathbf{net}_t^{l-1})+\delta_{o,t}^TW_{ox}\circ f’(\mathbf{net}_t^{l-1})\\ &amp;=(\delta_{f,t}^TW_{fx}+\delta_{i,t}^TW_{ix}+\delta_{\tilde{c},t}^TW_{cx}+\delta_{o,t}^TW_{ox})\circ f’(\mathbf{net}_t^{l-1})\qquad\quad(式14) \end{align} $</p>
<p><strong>式14</strong>就是将误差传递到上一层的公式。</p>
<h3 id="权重梯度的计算"><a href="#权重梯度的计算" class="headerlink" title="权重梯度的计算"></a>权重梯度的计算</h3><p>对于$W_{fh}$、$W_{ih}$、$W_{ch}$、$W_{oh}$的权重梯度，我们知道它的梯度是各个时刻梯度之和（证明过程请参考文章<a href="https://zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习(5) - 循环神经网络</a>），我们首先求出它们在t时刻的梯度，然后再求出他们最终的梯度。</p>
<p>我们已经求得了误差项$\delta_{o,t}$、$\delta_{f,t}$、$\delta_{i,t}$、$\delta_{\tilde{c},t}$，很容易求出t时刻的$W_{oh}$、$W_{ih}$、$W_{fh}$、$W_{ch}$的：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{W_{oh,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{o,t}}}\frac{\partial{\mathbf{net}_{o,t}}}{\partial{W_{oh,t}}}\\ &amp;=\delta_{o,t}\mathbf{h}_{t-1}^T\\\\ \frac{\partial{E}}{\partial{W_{fh,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{f,t}}}\frac{\partial{\mathbf{net}_{f,t}}}{\partial{W_{fh,t}}}\\ &amp;=\delta_{f,t}\mathbf{h}_{t-1}^T\\\\ \frac{\partial{E}}{\partial{W_{ih,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{i,t}}}\frac{\partial{\mathbf{net}_{i,t}}}{\partial{W_{ih,t}}}\\ &amp;=\delta_{i,t}\mathbf{h}_{t-1}^T\\\\ \frac{\partial{E}}{\partial{W_{ch,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{\tilde{c},t}}}\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{W_{ch,t}}}\\ &amp;=\delta_{\tilde{c},t}\mathbf{h}_{t-1}^T\\ \end{align} $</p>
<p>将各个时刻的梯度加在一起，就能得到最终的梯度：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{W_{oh}}}&amp;=\sum_{j=1}^t\delta_{o,j}\mathbf{h}_{j-1}^T\\ \frac{\partial{E}}{\partial{W_{fh}}}&amp;=\sum_{j=1}^t\delta_{f,j}\mathbf{h}_{j-1}^T\\ \frac{\partial{E}}{\partial{W_{ih}}}&amp;=\sum_{j=1}^t\delta_{i,j}\mathbf{h}_{j-1}^T\\ \frac{\partial{E}}{\partial{W_{ch}}}&amp;=\sum_{j=1}^t\delta_{\tilde{c},j}\mathbf{h}_{j-1}^T\\ \end{align} $</p>
<p>对于偏置项$\mathbf{b}_f$、$\mathbf{b}_i$、$\mathbf{b}_c$、$\mathbf{b}_o$的梯度，也是将各个时刻的梯度加在一起。下面是各个时刻的偏置项梯度：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{\mathbf{b}_{o,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{o,t}}}\frac{\partial{\mathbf{net}_{o,t}}}{\partial{\mathbf{b}_{o,t}}}\\ &amp;=\delta_{o,t}\\\\ \frac{\partial{E}}{\partial{\mathbf{b}_{f,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{f,t}}}\frac{\partial{\mathbf{net}_{f,t}}}{\partial{\mathbf{b}_{f,t}}}\\ &amp;=\delta_{f,t}\\\\ \frac{\partial{E}}{\partial{\mathbf{b}_{i,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{i,t}}}\frac{\partial{\mathbf{net}_{i,t}}}{\partial{\mathbf{b}_{i,t}}}\\ &amp;=\delta_{i,t}\\\\ \frac{\partial{E}}{\partial{\mathbf{b}_{c,t}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{\tilde{c},t}}}\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{\mathbf{b}_{c,t}}}\\ &amp;=\delta_{\tilde{c},t}\\ \end{align} $</p>
<p>下面是最终的偏置项梯度，即将各个时刻的偏置项梯度加在一起：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{\mathbf{b}_o}}&amp;=\sum_{j=1}^t\delta_{o,j}\\ \frac{\partial{E}}{\partial{\mathbf{b}_i}}&amp;=\sum_{j=1}^t\delta_{i,j}\\ \frac{\partial{E}}{\partial{\mathbf{b}_f}}&amp;=\sum_{j=1}^t\delta_{f,j}\\ \frac{\partial{E}}{\partial{\mathbf{b}_c}}&amp;=\sum_{j=1}^t\delta_{\tilde{c},j}\\ \end{align} $</p>
<p>对于$W_{fx}$、$W_{ix}$、$W_{cx}$、$W_{ox}$的权重梯度，只需要根据相应的误差项直接计算即可：</p>
<p>$\begin{align} \frac{\partial{E}}{\partial{W_{ox}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{o,t}}}\frac{\partial{\mathbf{net}_{o,t}}}{\partial{W_{ox}}}\\ &amp;=\delta_{o,t}\mathbf{x}_{t}^T\\\\ \frac{\partial{E}}{\partial{W_{fx}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{f,t}}}\frac{\partial{\mathbf{net}_{f,t}}}{\partial{W_{fx}}}\\ &amp;=\delta_{f,t}\mathbf{x}_{t}^T\\\\ \frac{\partial{E}}{\partial{W_{ix}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{i,t}}}\frac{\partial{\mathbf{net}_{i,t}}}{\partial{W_{ix}}}\\ &amp;=\delta_{i,t}\mathbf{x}_{t}^T\\\\ \frac{\partial{E}}{\partial{W_{cx}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}_{\tilde{c},t}}}\frac{\partial{\mathbf{net}_{\tilde{c},t}}}{\partial{W_{cx}}}\\ &amp;=\delta_{\tilde{c},t}\mathbf{x}_{t}^T\\ \end{align} $</p>
<p>以上就是LSTM的训练算法的全部公式。因为这里面存在很多重复的模式，仔细看看，会发觉并不是太复杂。</p>
<p>当然，LSTM存在着相当多的变体，读者可以在互联网上找到很多资料。因为大家已经熟悉了基本LSTM的算法，因此理解这些变体比较容易，因此本文就不再赘述了。</p>
<h2 id="长短时记忆网络的实现"><a href="#长短时记忆网络的实现" class="headerlink" title="长短时记忆网络的实现"></a>长短时记忆网络的实现</h2><blockquote>
<p>完整代码请参考GitHub: <a href="https://github.com/hanbt/learn_dl/blob/master/lstm.py" target="_blank" rel="noopener">https://github.com/hanbt/learn_dl/blob/master/lstm.py</a> (python2.7)</p>
</blockquote>
<p>在下面的实现中，LSTMLayer的参数包括输入维度、输出维度、隐藏层维度，单元状态维度等于隐藏层维度。gate的激活函数为sigmoid函数，输出的激活函数为tanh。</p>
<h3 id="激活函数的实现"><a href="#激活函数的实现" class="headerlink" title="激活函数的实现"></a>激活函数的实现</h3><p>我们先实现两个激活函数：sigmoid和tanh。</p>
<pre class=" language-lang-python"><code class="language-lang-python">class SigmoidActivator(object):
    def forward(self, weighted_input):
        return 1.0 / (1.0 + np.exp(-weighted_input))
    def backward(self, output):
        return output * (1 - output)
class TanhActivator(object):
    def forward(self, weighted_input):
        return 2.0 / (1.0 + np.exp(-2 * weighted_input)) - 1.0
    def backward(self, output):
        return 1 - output * output
</code></pre>
<h3 id="LSTM初始化"><a href="#LSTM初始化" class="headerlink" title="LSTM初始化"></a>LSTM初始化</h3><p>和前两篇文章代码架构一样，我们把LSTM的实现放在LstmLayer类中。</p>
<p>根据LSTM前向计算和方向传播算法，我们需要初始化一系列矩阵和向量。这些矩阵和向量有两类用途，一类是用于保存模型参数，例如$W_f$、$W_i$、$W_o$、$W_c$、$\mathbf{b}_f$、$\mathbf{b}_i$、$\mathbf{b}_o$、$\mathbf{b}_c$；另一类是保存各种中间计算结果，以便于反向传播算法使用，它们包括$\mathbf{h}_t$、$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{o}_t$、$\mathbf{\tilde{c}}_t$、$\mathbf{\tilde{c}}_t$、$\delta_t$、$\delta_{f,t}$、$\delta_{i,t}$、$\delta_{o,t}$、$\delta_{\tilde{c},t}$，以及各个权重对应的梯度。</p>
<p>在构造函数的初始化中，只初始化了与forward计算相关的变量，与backward相关的变量没有初始化。这是因为构造LSTM对象的时候，我们还不知道它未来是用于训练（既有forward又有backward）还是推理（只有forward）。</p>
<pre class=" language-lang-python"><code class="language-lang-python">class LstmLayer(object):
    def __init__(self, input_width, state_width, 
                 learning_rate):
        self.input_width = input_width
        self.state_width = state_width
        self.learning_rate = learning_rate
        # 门的激活函数
        self.gate_activator = SigmoidActivator()
        # 输出的激活函数
        self.output_activator = TanhActivator()
        # 当前时刻初始化为t0
        self.times = 0       
        # 各个时刻的单元状态向量c
        self.c_list = self.init_state_vec()
        # 各个时刻的输出向量h
        self.h_list = self.init_state_vec()
        # 各个时刻的遗忘门f
        self.f_list = self.init_state_vec()
        # 各个时刻的输入门i
        self.i_list = self.init_state_vec()
        # 各个时刻的输出门o
        self.o_list = self.init_state_vec()
        # 各个时刻的即时状态c~
        self.ct_list = self.init_state_vec()
        # 遗忘门权重矩阵Wfh, Wfx, 偏置项bf
        self.Wfh, self.Wfx, self.bf = (
            self.init_weight_mat())
        # 输入门权重矩阵Wfh, Wfx, 偏置项bf
        self.Wih, self.Wix, self.bi = (
            self.init_weight_mat())
        # 输出门权重矩阵Wfh, Wfx, 偏置项bf
        self.Woh, self.Wox, self.bo = (
            self.init_weight_mat())
        # 单元状态权重矩阵Wfh, Wfx, 偏置项bf
        self.Wch, self.Wcx, self.bc = (
            self.init_weight_mat())
    def init_state_vec(self):
        '''
        初始化保存状态的向量
        '''
        state_vec_list = []
        state_vec_list.append(np.zeros(
            (self.state_width, 1)))
        return state_vec_list
    def init_weight_mat(self):
        '''
        初始化权重矩阵
        '''
        Wh = np.random.uniform(-1e-4, 1e-4,
            (self.state_width, self.state_width))
        Wx = np.random.uniform(-1e-4, 1e-4,
            (self.state_width, self.input_width))
        b = np.zeros((self.state_width, 1))
        return Wh, Wx, b
</code></pre>
<h3 id="前向计算的实现"><a href="#前向计算的实现" class="headerlink" title="前向计算的实现"></a>前向计算的实现</h3><p>forward方法实现了LSTM的前向计算：</p>
<pre class=" language-lang-python"><code class="language-lang-python">        def forward(self, x):
        '''
        根据式1-式6进行前向计算
        '''
        self.times += 1
        # 遗忘门
        fg = self.calc_gate(x, self.Wfx, self.Wfh, 
            self.bf, self.gate_activator)
        self.f_list.append(fg)
        # 输入门
        ig = self.calc_gate(x, self.Wix, self.Wih,
            self.bi, self.gate_activator)
        self.i_list.append(ig)
        # 输出门
        og = self.calc_gate(x, self.Wox, self.Woh,
            self.bo, self.gate_activator)
        self.o_list.append(og)
        # 即时状态
        ct = self.calc_gate(x, self.Wcx, self.Wch,
            self.bc, self.output_activator)
        self.ct_list.append(ct)
        # 单元状态
        c = fg * self.c_list[self.times - 1] + ig * ct
        self.c_list.append(c)
        # 输出
        h = og * self.output_activator.forward(c)
        self.h_list.append(h)
    def calc_gate(self, x, Wx, Wh, b, activator):
        '''
        计算门
        '''
        h = self.h_list[self.times - 1] # 上次的LSTM输出
        net = np.dot(Wh, h) + np.dot(Wx, x) + b
        gate = activator.forward(net)
        return gate
</code></pre>
<p>从上面的代码我们可以看到，门的计算都是相同的算法，而门和的计算仅仅是激活函数不同。因此我们提出了calc_gate方法，这样减少了很多重复代码。</p>
<h3 id="反向传播算法的实现"><a href="#反向传播算法的实现" class="headerlink" title="反向传播算法的实现"></a>反向传播算法的实现</h3><p>backward方法实现了LSTM的反向传播算法。需要注意的是，与backword相关的内部状态变量是在调用backward方法之后才初始化的。这种延迟初始化的一个好处是，如果LSTM只是用来推理，那么就不需要初始化这些变量，节省了很多内存。</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def backward(self, x, delta_h, activator):
        '''
        实现LSTM训练算法
        '''
        self.calc_delta(delta_h, activator)
        self.calc_gradient(x)
</code></pre>
<p>算法主要分成两个部分，一部分使计算误差项：</p>
<pre class=" language-lang-python"><code class="language-lang-python">        def calc_delta(self, delta_h, activator):
        # 初始化各个时刻的误差项
        self.delta_h_list = self.init_delta()  # 输出误差项
        self.delta_o_list = self.init_delta()  # 输出门误差项
        self.delta_i_list = self.init_delta()  # 输入门误差项
        self.delta_f_list = self.init_delta()  # 遗忘门误差项
        self.delta_ct_list = self.init_delta() # 即时输出误差项
        # 保存从上一层传递下来的当前时刻的误差项
        self.delta_h_list[-1] = delta_h
        # 迭代计算每个时刻的误差项
        for k in range(self.times, 0, -1):
            self.calc_delta_k(k)
    def init_delta(self):
        '''
        初始化误差项
        '''
        delta_list = []
        for i in range(self.times + 1):
            delta_list.append(np.zeros(
                (self.state_width, 1)))
        return delta_list
    def calc_delta_k(self, k):
        '''
        根据k时刻的delta_h，计算k时刻的delta_f、
        delta_i、delta_o、delta_ct，以及k-1时刻的delta_h
        '''
        # 获得k时刻前向计算的值
        ig = self.i_list[k]
        og = self.o_list[k]
        fg = self.f_list[k]
        ct = self.ct_list[k]
        c = self.c_list[k]
        c_prev = self.c_list[k-1]
        tanh_c = self.output_activator.forward(c)
        delta_k = self.delta_h_list[k]
        # 根据式9计算delta_o
        delta_o = (delta_k * tanh_c * 
            self.gate_activator.backward(og))
        delta_f = (delta_k * og * 
            (1 - tanh_c * tanh_c) * c_prev *
            self.gate_activator.backward(fg))
        delta_i = (delta_k * og * 
            (1 - tanh_c * tanh_c) * ct *
            self.gate_activator.backward(ig))
        delta_ct = (delta_k * og * 
            (1 - tanh_c * tanh_c) * ig *
            self.output_activator.backward(ct))
        delta_h_prev = (
                np.dot(delta_o.transpose(), self.Woh) +
                np.dot(delta_i.transpose(), self.Wih) +
                np.dot(delta_f.transpose(), self.Wfh) +
                np.dot(delta_ct.transpose(), self.Wch)
            ).transpose()
        # 保存全部delta值
        self.delta_h_list[k-1] = delta_h_prev
        self.delta_f_list[k] = delta_f
        self.delta_i_list[k] = delta_i
        self.delta_o_list[k] = delta_o
        self.delta_ct_list[k] = delta_ct
</code></pre>
<p>另一部分是计算梯度：</p>
<pre class=" language-lang-python"><code class="language-lang-python">     def calc_gradient(self, x):
        # 初始化遗忘门权重梯度矩阵和偏置项
        self.Wfh_grad, self.Wfx_grad, self.bf_grad = (
            self.init_weight_gradient_mat())
        # 初始化输入门权重梯度矩阵和偏置项
        self.Wih_grad, self.Wix_grad, self.bi_grad = (
            self.init_weight_gradient_mat())
        # 初始化输出门权重梯度矩阵和偏置项
        self.Woh_grad, self.Wox_grad, self.bo_grad = (
            self.init_weight_gradient_mat())
        # 初始化单元状态权重梯度矩阵和偏置项
        self.Wch_grad, self.Wcx_grad, self.bc_grad = (
            self.init_weight_gradient_mat())
       # 计算对上一次输出h的权重梯度
        for t in range(self.times, 0, -1):
            # 计算各个时刻的梯度
            (Wfh_grad, bf_grad,
            Wih_grad, bi_grad,
            Woh_grad, bo_grad,
            Wch_grad, bc_grad) = (
                self.calc_gradient_t(t))
            # 实际梯度是各时刻梯度之和
            self.Wfh_grad += Wfh_grad
            self.bf_grad += bf_grad
            self.Wih_grad += Wih_grad
            self.bi_grad += bi_grad
            self.Woh_grad += Woh_grad
            self.bo_grad += bo_grad
            self.Wch_grad += Wch_grad
            self.bc_grad += bc_grad
            print '-----%d-----' % t
            print Wfh_grad
            print self.Wfh_grad
        # 计算对本次输入x的权重梯度
        xt = x.transpose()
        self.Wfx_grad = np.dot(self.delta_f_list[-1], xt)
        self.Wix_grad = np.dot(self.delta_i_list[-1], xt)
        self.Wox_grad = np.dot(self.delta_o_list[-1], xt)
        self.Wcx_grad = np.dot(self.delta_ct_list[-1], xt)
    def init_weight_gradient_mat(self):
        '''
        初始化权重矩阵
        '''
        Wh_grad = np.zeros((self.state_width,
            self.state_width))
        Wx_grad = np.zeros((self.state_width,
            self.input_width))
        b_grad = np.zeros((self.state_width, 1))
        return Wh_grad, Wx_grad, b_grad
    def calc_gradient_t(self, t):
        '''
        计算每个时刻t权重的梯度
        '''
        h_prev = self.h_list[t-1].transpose()
        Wfh_grad = np.dot(self.delta_f_list[t], h_prev)
        bf_grad = self.delta_f_list[t]
        Wih_grad = np.dot(self.delta_i_list[t], h_prev)
        bi_grad = self.delta_f_list[t]
        Woh_grad = np.dot(self.delta_o_list[t], h_prev)
        bo_grad = self.delta_f_list[t]
        Wch_grad = np.dot(self.delta_ct_list[t], h_prev)
        bc_grad = self.delta_ct_list[t]
        return Wfh_grad, bf_grad, Wih_grad, bi_grad, \
               Woh_grad, bo_grad, Wch_grad, bc_grad
</code></pre>
<h3 id="梯度下降算法的实现"><a href="#梯度下降算法的实现" class="headerlink" title="梯度下降算法的实现"></a>梯度下降算法的实现</h3><p>下面是用梯度下降算法来更新权重：</p>
<pre class=" language-lang-python"><code class="language-lang-python">    def update(self):
        '''
        按照梯度下降，更新权重
        '''
        self.Wfh -= self.learning_rate * self.Whf_grad
        self.Wfx -= self.learning_rate * self.Whx_grad
        self.bf -= self.learning_rate * self.bf_grad
        self.Wih -= self.learning_rate * self.Whi_grad
        self.Wix -= self.learning_rate * self.Whi_grad
        self.bi -= self.learning_rate * self.bi_grad
        self.Woh -= self.learning_rate * self.Wof_grad
        self.Wox -= self.learning_rate * self.Wox_grad
        self.bo -= self.learning_rate * self.bo_grad
        self.Wch -= self.learning_rate * self.Wcf_grad
        self.Wcx -= self.learning_rate * self.Wcx_grad
        self.bc -= self.learning_rate * self.bc_grad
</code></pre>
<h3 id="梯度检查的实现"><a href="#梯度检查的实现" class="headerlink" title="梯度检查的实现"></a>梯度检查的实现</h3><p>和RecurrentLayer一样，为了支持梯度检查，我们需要支持重置内部状态：</p>
<pre><code>    def reset_state(self):
        # 当前时刻初始化为t0
        self.times = 0       
        # 各个时刻的单元状态向量c
        self.c_list = self.init_state_vec()
        # 各个时刻的输出向量h
        self.h_list = self.init_state_vec()
        # 各个时刻的遗忘门f
        self.f_list = self.init_state_vec()
        # 各个时刻的输入门i
        self.i_list = self.init_state_vec()
        # 各个时刻的输出门o
        self.o_list = self.init_state_vec()
        # 各个时刻的即时状态c~
        self.ct_list = self.init_state_vec()
</code></pre><p>最后，是梯度检查的代码：</p>
<pre class=" language-lang-python"><code class="language-lang-python">def data_set():
    x = [np.array([[1], [2], [3]]),
         np.array([[2], [3], [4]])]
    d = np.array([[1], [2]])
    return x, d
def gradient_check():
    '''
    梯度检查
    '''
    # 设计一个误差函数，取所有节点输出项之和
    error_function = lambda o: o.sum()
    lstm = LstmLayer(3, 2, 1e-3)
    # 计算forward值
    x, d = data_set()
    lstm.forward(x[0])
    lstm.forward(x[1])
    # 求取sensitivity map
    sensitivity_array = np.ones(lstm.h_list[-1].shape,
                                dtype=np.float64)
    # 计算梯度
    lstm.backward(x[1], sensitivity_array, IdentityActivator())
    # 检查梯度
    epsilon = 10e-4
    for i in range(lstm.Wfh.shape[0]):
        for j in range(lstm.Wfh.shape[1]):
            lstm.Wfh[i,j] += epsilon
            lstm.reset_state()
            lstm.forward(x[0])
            lstm.forward(x[1])
            err1 = error_function(lstm.h_list[-1])
            lstm.Wfh[i,j] -= 2*epsilon
            lstm.reset_state()
            lstm.forward(x[0])
            lstm.forward(x[1])
            err2 = error_function(lstm.h_list[-1])
            expect_grad = (err1 - err2) / (2 * epsilon)
            lstm.Wfh[i,j] += epsilon
            print 'weights(%d,%d): expected - actural %.4e - %.4e' % (
                i, j, expect_grad, lstm.Wfh_grad[i,j])
    return lstm
</code></pre>
<p>我们只对$W_{fh}$做了检查，读者可以自行增加对其他梯度的检查。下面是某次梯度检查的结果：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-cb1c4561375c22a1.png)</p>
<h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><p>前面我们讲了一种普通的LSTM，事实上LSTM存在很多<strong>变体</strong>，许多论文中的LSTM都或多或少的不太一样。在众多的LSTM变体中，<strong>GRU (Gated Recurrent Unit)</strong>也许是最成功的一种。它对LSTM做了很多简化，同时却保持着和LSTM相同的效果。因此，GRU最近变得越来越流行。</p>
<p>GRU对LSTM做了两个大改动：</p>
<ol>
<li>将输入门、遗忘门、输出门变为两个门：更新门（Update Gate）$\mathbf{z}_t$和重置门（Reset Gate）$\mathbf{r}_t$。</li>
<li>将单元状态与输出合并为一个状态：$\mathbf{h}$。</li>
</ol>
<p>GRU的前向计算公式为：</p>
<p>$\begin{align} \mathbf{z}_t&amp;=\sigma(W_z\cdot[\mathbf{h}_{t-1},\mathbf{x}_t])\\ \mathbf{r}_t&amp;=\sigma(W_r\cdot[\mathbf{h}_{t-1},\mathbf{x}_t])\\ \mathbf{\tilde{h}}_t&amp;=\tanh(W\cdot[\mathbf{r}_t\circ\mathbf{h}_{t-1},\mathbf{x}_t])\\ \mathbf{h}&amp;=(1-\mathbf{z}_t)\circ\mathbf{h}_{t-1}+\mathbf{z}_t\circ\mathbf{\tilde{h}}_t \end{align} $</p>
<p>下图是GRU的示意图：</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-b784d887bf693253.png)</p>
<p>GRU的训练算法比LSTM简单一些，留给读者自行推导，本文就不再赘述了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，LSTM——也许是结构最复杂的一类神经网络——就讲完了，相信拿下前几篇文章的读者们搞定这篇文章也不在话下吧！现在我们已经了解<strong>循环神经网络</strong>和它最流行的变体——<strong>LSTM</strong>，它们都可以用来处理序列。但是，有时候仅仅拥有处理序列的能力还不够，还需要处理比序列更为复杂的结构（比如树结构），这时候就需要用到另外一类网络：<strong>递归神经网络(Recursive Neural Network)</strong>，巧合的是，它的缩写也是<strong>RNN</strong>。在下一篇文章中，我们将介绍<strong>递归神经网络</strong>和它的训练算法。现在，漫长的烧脑暂告一段落，休息一下吧:)</p>
<p><img src="%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(6" alt="img">%20-%20%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C(LSTM)/2256672-9ba33f65294bfb98.jpg)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://cs224d.stanford.edu/" target="_blank" rel="noopener">CS224d: Deep Learning for Natural Language Processing</a></li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li>
<li><a href="http://arunmallya.github.io/writeups/nn/lstm/index.html" target="_blank" rel="noopener">LSTM Forward and Backward Pass</a></li>
</ol>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lunyang.github.io" rel="external nofollow noreferrer">lunyang</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lunyang.github.io">https://lunyang.github.io</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://lunyang.github.io" target="_blank">lunyang</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="../ling-ji-chu-ru-men-shen-du-xue-xi-5-xun-huan-shen-jing-wang-luo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="零基础入门深度学习-循环神经网络">
                        
                        <span class="card-title">零基础入门深度学习-循环神经网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            参考资料：https://www.zybuluo.com/hanbingtao/note/541458

%20-%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/22566
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-12-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="../categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    深度学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="../other/generate-tweets-using-markov-chain/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Generate Tweets Using Markov Chains">
                        
                        <span class="card-title">Generate Tweets Using Markov Chains</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Preliminariesimport markovify

Load CorpusThe corpus I am using is just one I found online. The corpus you choose is cen
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2017-12-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Chris Albon
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://lunyang.github.io" target="_blank">lunyang</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:53917181@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="../atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
